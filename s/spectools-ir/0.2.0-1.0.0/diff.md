# Comparing `tmp/spectools_ir-0.2.0-py3-none-any.whl.zip` & `tmp/spectools_ir-1.0.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,22 +1,21 @@
-Zip file size: 38016 bytes, number of entries: 20
+Zip file size: 33424 bytes, number of entries: 19
 -rw-r--r--  2.0 unx        2 b- defN 21-Apr-21 19:55 spectools_ir/__init__.py
--rw-r--r--  2.0 unx     8537 b- defN 22-Jun-30 22:01 spectools_ir/flux_calculator/#helpers.py#
 -rw-r--r--  2.0 unx       57 b- defN 21-Apr-22 15:49 spectools_ir/flux_calculator/__init__.py
--rw-r--r--  2.0 unx    13931 b- defN 22-Jun-30 02:12 spectools_ir/flux_calculator/flux_calculator.py
--rw-r--r--  2.0 unx     8537 b- defN 21-Apr-29 18:07 spectools_ir/flux_calculator/helpers.py
+-rw-r--r--  2.0 unx    15081 b- defN 23-Jun-19 22:29 spectools_ir/flux_calculator/flux_calculator.py
+-rw-r--r--  2.0 unx     8537 b- defN 22-Oct-24 20:59 spectools_ir/flux_calculator/helpers.py
 -rw-r--r--  2.0 unx      217 b- defN 21-Jun-01 20:02 spectools_ir/slab_fitter/__init__.py
 -rw-r--r--  2.0 unx      150 b- defN 21-Jul-20 00:58 spectools_ir/slab_fitter/config.json
 -rw-r--r--  2.0 unx     5978 b- defN 21-Jun-01 16:48 spectools_ir/slab_fitter/helpers.py
--rw-r--r--  2.0 unx     7554 b- defN 21-Jun-01 20:09 spectools_ir/slab_fitter/output.py
--rw-r--r--  2.0 unx    12255 b- defN 22-Jun-22 18:12 spectools_ir/slab_fitter/slab_fitter.py
--rw-r--r--  2.0 unx       33 b- defN 21-Apr-22 15:50 spectools_ir/slabspec/__init__.py
+-rw-r--r--  2.0 unx     7665 b- defN 23-Jun-19 22:29 spectools_ir/slab_fitter/output.py
+-rw-r--r--  2.0 unx    12248 b- defN 23-Jun-19 22:29 spectools_ir/slab_fitter/slab_fitter.py
+-rw-r--r--  2.0 unx       44 b- defN 23-Jun-19 22:29 spectools_ir/slabspec/__init__.py
 -rw-r--r--  2.0 unx     4389 b- defN 21-Jun-01 16:52 spectools_ir/slabspec/helpers.py
--rw-r--r--  2.0 unx    14364 b- defN 22-Jul-06 18:21 spectools_ir/slabspec/slabspec.py
+-rw-r--r--  2.0 unx    10909 b- defN 23-Jun-19 22:29 spectools_ir/slabspec/slabspec.py
 -rw-r--r--  2.0 unx      414 b- defN 22-Jul-06 18:21 spectools_ir/utils/__init__.py
--rw-r--r--  2.0 unx    48671 b- defN 22-Jul-06 18:21 spectools_ir/utils/utils.py
--rwxr-xr-x  2.0 unx     1074 b- defN 22-Jul-06 18:26 spectools_ir-0.2.0.dist-info/LICENSE
--rw-r--r--  2.0 unx     2675 b- defN 22-Jul-06 18:26 spectools_ir-0.2.0.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 22-Jul-06 18:26 spectools_ir-0.2.0.dist-info/WHEEL
--rw-r--r--  2.0 unx       13 b- defN 22-Jul-06 18:26 spectools_ir-0.2.0.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     1786 b- defN 22-Jul-06 18:26 spectools_ir-0.2.0.dist-info/RECORD
-20 files, 130729 bytes uncompressed, 35054 bytes compressed:  73.2%
+-rw-r--r--  2.0 unx    34027 b- defN 23-Jun-20 15:02 spectools_ir/utils/utils.py
+-rwxr-xr-x  2.0 unx     1074 b- defN 23-Jun-20 15:22 spectools_ir-1.0.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx     2712 b- defN 23-Jun-20 15:22 spectools_ir-1.0.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jun-20 15:22 spectools_ir-1.0.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx       13 b- defN 23-Jun-20 15:22 spectools_ir-1.0.0.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     1688 b- defN 23-Jun-20 15:22 spectools_ir-1.0.0.dist-info/RECORD
+19 files, 105297 bytes uncompressed, 30620 bytes compressed:  70.9%
```

## zipnote {}

```diff
@@ -1,13 +1,10 @@
 Filename: spectools_ir/__init__.py
 Comment: 
 
-Filename: spectools_ir/flux_calculator/#helpers.py#
-Comment: 
-
 Filename: spectools_ir/flux_calculator/__init__.py
 Comment: 
 
 Filename: spectools_ir/flux_calculator/flux_calculator.py
 Comment: 
 
 Filename: spectools_ir/flux_calculator/helpers.py
@@ -39,23 +36,23 @@
 
 Filename: spectools_ir/utils/__init__.py
 Comment: 
 
 Filename: spectools_ir/utils/utils.py
 Comment: 
 
-Filename: spectools_ir-0.2.0.dist-info/LICENSE
+Filename: spectools_ir-1.0.0.dist-info/LICENSE
 Comment: 
 
-Filename: spectools_ir-0.2.0.dist-info/METADATA
+Filename: spectools_ir-1.0.0.dist-info/METADATA
 Comment: 
 
-Filename: spectools_ir-0.2.0.dist-info/WHEEL
+Filename: spectools_ir-1.0.0.dist-info/WHEEL
 Comment: 
 
-Filename: spectools_ir-0.2.0.dist-info/top_level.txt
+Filename: spectools_ir-1.0.0.dist-info/top_level.txt
 Comment: 
 
-Filename: spectools_ir-0.2.0.dist-info/RECORD
+Filename: spectools_ir-1.0.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## spectools_ir/flux_calculator/flux_calculator.py

```diff
@@ -8,15 +8,15 @@
 
 from spectools_ir.utils import extract_hitran_data, fwhm_to_sigma, sigma_to_fwhm
 from .helpers import _line_fit, _calc_linewidth, _calc_line_flux_from_fit
 from .helpers import _strip_superfluous_hitran_data, _convert_quantum_strings
 from .helpers import _calc_numerical_flux
 
 def calc_fluxes(wave,flux,hitran_data, fwhm_v=20., sep_v=40.,cont=1.,verbose=True,vet_fits=False,
-                plot=False,v_dop=0,amp=0.1,ymin=None,ymax=None):
+                plot=False,v_dop=0,amp=0.1,ymin=None,ymax=None,bounds=None):
     '''                                                                                     
                                                                                             
     Parameters                                                                              
     ---------                                                                               
     wave : numpy array                                                                      
         wavelength values, in microns                                                       
     flux : numpy array                                                                      
@@ -40,14 +40,18 @@
     vet_fits: bool, optional - defaults to False
         If True, user is prompted to decide if fit is good or not.
     plot: bool, optional - defaults to False
         If True, data and fits are plotted.  If vet_fits=True, this gets set to True automatically.
     v_dop : float, optional (defaults to 0)
         Doppler shift in km/s of spectrum relative to vacuum.  Note that this makes no assumptions about
          reference frame.
+    bounds : Lower and upper bounds on parameters.  Tuple where each element is an array with 
+           length 4, or single number.  Use np.inf to disable bounds on some parameters.
+           e.g., bounds=[[-np.inf,-np.inf,-np.inf,-1e-6],[np.inf,np.inf,np.inf,1e-6]] 
+           https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.curve_fit.html
 
     Returns                                                                                 
     --------                                                                                
     lineflux_data : astropy table
        Table holding both HITRAN data and fit parameters (including flux, line width, and Doppler shift) 
         for fit lines.  
                                                                                             
@@ -64,14 +68,18 @@
     lineflux_data['lineflux_err']=np.zeros(nlines)  
     lineflux_data['linewidth']=np.zeros(nlines)
     lineflux_data['linewidth_err']=np.zeros(nlines)
     lineflux_data['v_dop_fit']=np.zeros(nlines)  
     lineflux_data['v_dop_fit_err']=np.zeros(nlines)  
     lineflux_data['continuum']=np.zeros(nlines)  
     lineflux_data['continuum_err']=np.zeros(nlines)  
+    lineflux_data['wave_fit']=np.zeros(nlines)  
+    lineflux_data['wave_fit_err']=np.zeros(nlines)  
+    lineflux_data['amp_fit']=np.zeros(nlines)  
+    lineflux_data['amp_fit_err']=np.zeros(nlines)  
     goodfit_bool=[True]*nlines
     #Loop through HITRAN wavelengths
     for i,w0 in enumerate(lineflux_data['wave']):   
         #Perform Gaussian fit for each line
         #Calculate Doppler shift, line width, and line separation in microns
         wdop=v_dop*1e3/c.value*w0
         dw=sep_v*1e3/c.value*w0
@@ -80,17 +88,19 @@
         mybool=((wave>(w0+wdop-dw)) & (wave<(w0+wdop+dw)) & np.isfinite(flux))
         myx=wave[mybool]
         myy=flux[mybool]
         if((len(myx) <= 5) & (verbose==True) ):
             print('Not enough data near ', w0+wdop, ' microns. Skipping.')
             goodfit_bool[i]=False
         if(len(myx) > 5):
-            g=_line_fit(np.array(myx),np.array(myy),nterms=4,p0=[amp,w0+wdop,sig_w,cont])
+            print('Starting params:',amp,w0+wdop,sig_w,cont)
+            g=_line_fit(np.array(myx),np.array(myy),nterms=4,p0=[amp,w0+wdop,sig_w,cont],bounds=bounds)
             if(g!=-1):   #curve fit succeeded
                 p=g['parameters']
+                print('Fit params:', p[0],p[1],p[2],p[3])
                 perr=g['parameter_errors']
                 resid=g['resid']
                 sigflux=np.sqrt(np.mean(resid**2.))
                 (lineflux,lineflux_err)=_calc_line_flux_from_fit(p,sigflux=sigflux)
                 lineflux_data['lineflux_Gaussian'][i]=lineflux.value
                 lineflux_data['lineflux_err'][i]=lineflux_err.value
                 lineflux_num=_calc_numerical_flux(myx,myy,p)
@@ -98,14 +108,20 @@
                 lineflux_data['linewidth'][i]=np.abs((_calc_linewidth(p,perr=perr))[0].value)
                 lineflux_data['linewidth_err'][i]=np.abs((_calc_linewidth(p,perr=perr))[1].value)
                 lineflux_data['v_dop_fit'][i]=(p[1]-w0)/w0*c.value*1e-3   #km/s
                 lineflux_data['v_dop_fit_err'][i]=(perr[1])/w0*c.value*1e-3   #km/s
                 lineflux_data['continuum'][i]=(p[3])   #Jy
                 lineflux_data['continuum_err'][i]=(perr[3])   #Jy
 
+                lineflux_data['wave_fit'][i]=p[1] #microns
+                lineflux_data['wave_fit_err'][i]=perr[1] #microns
+                lineflux_data['amp_fit'][i]=p[0] #Jy
+                lineflux_data['amp_fit_err'][i]=perr[0] #Jy
+                
+
                 if(plot==True):
                     fig=plt.figure(figsize=(10,3))
                     ax1=fig.add_subplot(111)
                     ax1.plot(wave,flux,'C0',drawstyle='steps-mid',label='All data')
                     ax1.plot(myx,myy,'C1',drawstyle='steps-mid',label='Fit data')
                     ax1.plot(myx,g['yfit'],'C2',label='Fit')
                     ax1.axvline(w0+wdop,color='C3',label='Line center')
@@ -152,14 +168,18 @@
     lineflux_data['lineflux_err'].unit = 'W / m2'
     lineflux_data['linewidth'].unit = 'km / s'
     lineflux_data['linewidth_err'].unit = 'km / s'
     lineflux_data['v_dop_fit'].unit = 'km / s'
     lineflux_data['v_dop_fit_err'].unit = 'km / s'
     lineflux_data['continuum'].unit = 'Jy'
     lineflux_data['continuum_err'].unit = 'Jy'
+    lineflux_data['amp_fit'].unit = 'Jy'
+    lineflux_data['amp_fit_err'].unit = 'Jy'
+    lineflux_data['wave_fit'].unit = 'micron'
+    lineflux_data['wave_fit_err'].unit = 'micron'
 
     lineflux_data=lineflux_data[goodfit_bool]
 
     return lineflux_data
     
 
 def make_lineshape(wave,flux, lineflux_data, dv=3., voffset=None,norm=None):
```

## spectools_ir/slab_fitter/output.py

```diff
@@ -96,14 +96,19 @@
      Array holding arrays of MCMC output samples after removal of burnin samples.                                                
     '''
     ndims = chain.shape[2]
     samples = chain[:, burnin:, :].reshape((-1, ndims))
     
     return samples
 
+def get_lnprob(mysampler,burnin):
+    lnprob=mysmpler.lnprobability[:,burnin:].reshape(-1)
+
+    return lnprob
+
 def _get_partition_function(mydata,temp):
     q=np.zeros(mydata.nlines)
     for myunique_id in mydata.unique_globals:
         myq=mydata.qdata_dict[str(myunique_id)][int(temp)-1]
         mybool=(mydata.global_id == myunique_id)
         q[mybool]=myq
     return q
```

## spectools_ir/slab_fitter/slab_fitter.py

```diff
@@ -116,15 +116,15 @@
         sampler.run_mcmc(inisamples, Nsamples+Nburnin)
         end_time=time.time()
         print("Number of total samples:", Nwalkers*Nsamples)
         print("Run time [s]:", end_time-start_time)
         #sampler.chain has dimensions (Nwalkers, Nburnin+Nsamples,ndims)
 #        samples = sampler.chain[:, Nburnin:, :].reshape((-1, ndims))  
 
-        return sampler.chain
+        return sampler
 
     def _lnprior(self, theta):
         lp = 0.  #initialize log prior
         logn, temp, logomega = theta # unpack the model parameters from the list                                             
         #First parameter: logn - uniform prior
         lognmin = self.Config.getpar('lognmin')  # lower range of prior                                                        
         lognmax = self.Config.getpar('lognmax')  # upper range of prior                                                        
@@ -256,15 +256,14 @@
         q_dict={}
         for myid in id_array:
             qurl='https://hitran.org/data/Q/'+'q'+str(myid)+'.txt'
             handle = urllib.request.urlopen(qurl)
             qdata = pd.read_csv(handle,sep=' ',skipinitialspace=True,names=['temp','q'],header=None)
             q_dict.update({str(myid):qdata['q']})
         return q_dict
-
 #------------------------------------------------------------------------------------                                     
     def rot_diagram(self,units='mks',modelfluxes=None):
         x=self.eup_k
         mywn0=self.wn0
         y=np.log(self.lineflux/(mywn0*self.gup*self.aup))  #All mks, so wn in m^-1
         if(units=='cgs'):
             y=np.log(1000.*self.lineflux/((self.wn0*1e-2)*self.gup*self.aup))   #All cgs
```

## spectools_ir/slabspec/__init__.py

```diff
@@ -1,2 +1 @@
-from .slabspec import make_spec
-
+from .slabspec import make_spec, write_slab
```

## spectools_ir/slabspec/slabspec.py

```diff
@@ -1,105 +1,38 @@
+import sys
+
 import numpy as np
 import urllib
 import pandas as pd
+import pdb as pdb
 
-import sys
+from scipy.interpolate import interp1d
 
 from astropy.table import Table
 from astropy import units as un
 from astropy.io import fits
 from astropy.constants import c,h, k_B, G, M_sun, au, pc, u
-from astropy.convolution import Gaussian1DKernel, convolve
+from astropy.convolution import Gaussian1DKernel, convolve_fft
 
 from spectools_ir.utils import _check_hitran
 from spectools_ir.utils import fwhm_to_sigma, sigma_to_fwhm, compute_thermal_velocity, extract_hitran_data
-from spectools_ir.utils import  get_molecule_identifier, get_global_identifier, spec_convol, extract_hitran_from_par
+from spectools_ir.utils import get_molecule_identifier, get_global_identifier, spec_convol, extract_hitran_from_par
 from .helpers import _strip_superfluous_hitran_data, _convert_quantum_strings
 
-def _spec_convol_klaus(wave,flux,R):
-    '''
-    Convolve a spectrum, given wavelength in microns and flux density, by a given FWHM in velocity 
-
-    Parameters
-    ---------
-    wave : numpy array
-        wavelength values, in microns
-    flux : numpy array
-        flux density values, in units of Energy/area/time/Hz
-    R : float
-        Resolving power (lambda / dlambda)
-
-    Returns
-    --------
-    newflux : numpy array
-        Convolved spectrum flux density values, in same units as input
-
-    '''                                 
-    # find the minimum spacing between wavelengths in the dataset
-    dws = np.abs(wave - np.roll(wave, 1))
-    dw_min = np.min(dws)   #Minimum delta-wavelength between points in dataset
-
-    fwhm = wave / R  # FWHM of resolution element as a function of wavelength ("delta lambda" in same units as wave)
-    #fwhm / dw_min gives FWHM values expressed in units of minimum spacing, or the sampling for each wavelength
-    #(sampling is sort of the number of data points per FWHM)
-    #The sampling is different for each point in the wavelength array, because the FWHM is wavelength dependent
-    #fwhm_s then gives the minimum value of the sampling - the most poorly sampled wavelength.
-    fwhm_s = np.min(fwhm / dw_min)  # find mininumvalue of sampling for this dataset
-    # but do not allow the sampling FWHM to be less than Nyquist
-    # (i.e., make sure there are at least two points per resolution element)
-    fwhm_s = np.max([2., fwhm_s])  #Will return 2 only if fwhm_s is less than 2
-    #If you want all wavelengths to have the same sampling per resolution element, 
-    #then this ds gives the wavelength spacing for each wavelength (in units of wavelength)
-    ds = fwhm / fwhm_s
-    # use the min wavelength as a starting point
-    w = np.min(wave)
-    #Initialize array to hold new wavelength values
-    #Note: it's much faster (~50%) to append to lists than np.array()'s
-    wave_constfwhm = []
-
-
-    # doing this as a loop is slow, but straightforward.
-    while w < np.max(wave):
-        # use interpolation to get delta-wavelength from the sampling as a function of wavelength.
-        # this method is over 5x faster than the original use of scipy.interpolate.interp1d.
-        w += np.interp(w,wave,ds)  #Get value of ds at w, then add to old value of w
-        wave_constfwhm.append(w)
-
-    wave_constfwhm.pop()  # remove last point which is an extrapolation
-    wave_constfwhm = np.array(wave_constfwhm)  #Convert list to numpy array
-    
-    # interpolate the flux onto the new wavelength set
-    flux_constfwhm = np.interp(wave_constfwhm,wave,flux)
-
-    # convolve the flux with a gaussian kernel; first convert the FWHM to sigma
-    sigma_s = fwhm_s / 2.3548
-    try:
-        # for astropy < 0.4
-        g = Gaussian1DKernel(width=sigma_s)
-    except TypeError:
-        # for astropy >= 0.4
-        g = Gaussian1DKernel(sigma_s)
-    # use boundary='extend' to set values outside the array to nearest array value.
-    # this is the best approximation in this case.
-    flux_conv = convolve(flux_constfwhm, g, normalize_kernel=True, boundary='extend')
-    flux_oldsampling = np.interp(wave, wave_constfwhm, flux_conv)
-
-    return flux_oldsampling
-
-#------------------------------------------------------------------------------------                                     
-def make_spec(molecule_name, n_col, temp, area, wmax=40, wmin=1, res=1e-4, deltav=None, isotopologue_number=1, d_pc=1,
+#------------------------------------------------------------------------------------
+def make_spec(molecule_name, n_col, temp, area, wmax=40, wmin=1, deltav=None, isotopologue_number=1, d_pc=1,
               aupmin=None, convol_fwhm=None, eupmax=None, vup=None, swmin=None, parfile=None):
 
     '''
     Create an IR spectrum for a slab model with given temperature, area, and column density
 
     Parameters
     ---------
     molecule_name : string
-        String identifier for molecule, for example, 'CO', or 'H2O'             
+        String identifier for molecule, for example, 'CO', or 'H2O'
     n_col : float
         Column density, in m^-2
     temp : float
         Temperature of slab model, in K
     area : float
         Area of slab model, in m^2
     wmin : float, optional
@@ -115,184 +48,226 @@
         Distance to slab, in units of pc, for computing observed flux density.  Defaults to 1 pc.
     aupmin : float, optional
         Minimum Einstein-A coefficient for transitions
     swmin : float, optional
         Minimum line strength for transitions
     convol_fwhm : float, optional
         FWHM of convolution kernel, in km/s.
-    res : float, optional
-        max resolution of spectrum, in microns.  Must be significantly higher than observed spectrum for correct calculation.
-        Defaults to 1e-4.
     eupmax : float, optional
         Maximum energy of transitions to consider, in K
     vup : float, optional
         Optional parameter to restrict output to certain upper level vibrational states.  Only works if 'Vp' field is a single integer.
 
     Returns
     --------
     slabdict : dictionary
-        Dictionary includes two astropy tables: 
+        Dictionary includes two astropy tables:
           lineparams : line parameters from HITRAN, integrated line fluxes, peak tau
           spectrum : wavelength, flux, convolflux, tau
         and two dictionaries
           lines : wave_arr (in microns), flux_arr (in mks), velocity (in km/s) - for plotting individual lines
           modelparams : model parameters: Area, column density, temperature, local velocity, convolution fwhm
     '''
-    isot=isotopologue_number
-    si2jy=1e26   #SI to Jy flux conversion factor
+    oversamp = 3
+    isot = isotopologue_number
+    si2jy = 1e26   #SI to Jy flux conversion factor
 
-#Test whether molecule is in HITRAN database.  If not, check for parfile and warn.
-    database=_check_hitran(molecule_name)
+    #Test whether molecule is in HITRAN database.  If not, check for parfile and warn.
+    database = _check_hitran(molecule_name)
     if((database=='exomol') & (parfile is None)):
         print('This molecule is not in the HITRAN database.  You must provide a HITRAN-format parfile for this molecule.  Exiting.')
         sys.exit()
     if(database is None):
         print('This molecule is not covered by this code at this time.  Exiting.')
         sys.exit()
 
-#If local velocity field is not given, assume sigma given by thermal velocity
+    #If local velocity field is not given, assume sigma given by thermal velocity
     if(deltav is None):
-        deltav=compute_thermal_velocity(molecule_name, temp)
+        deltav = compute_thermal_velocity(molecule_name, temp)
 
-#Read HITRAN data
+    #Read HITRAN data
     if(parfile is not None):
-        hitran_data=extract_hitran_from_par(parfile,aupmin=aupmin,eupmax=eupmax,isotopologue_number=isotopologue_number,vup=vup,wavemin=wmin,wavemax=wmax)
+        hitran_data = extract_hitran_from_par(parfile,aupmin=aupmin,eupmax=eupmax,isotopologue_number=isotopologue_number,vup=vup,wavemin=wmin,wavemax=wmax)
     else:  #parfile not provided.  Read using extract_hitran_data
-        try:    
-            hitran_data=extract_hitran_data(molecule_name,wmin,wmax,isotopologue_number=isotopologue_number, eupmax=eupmax, aupmin=aupmin, swmin=swmin, vup=vup)
+        try:
+            hitran_data = extract_hitran_data(molecule_name,wmin,wmax,isotopologue_number=isotopologue_number, eupmax=eupmax, aupmin=aupmin, swmin=swmin, vup=vup)
         except:
             print("astroquery call to HITRAN failed. This can happen when your molecule does not have any lines in the requested wavelength region")
             sys.exit(1)
-           
-    wn0=hitran_data['wn']*1e2 # now m-1
-    aup=hitran_data['a']
-    eup=(hitran_data['elower']+hitran_data['wn'])*1e2 #now m-1                                                             
-    gup=hitran_data['gp']
-
-#Compute partition function
-    q=_compute_partition_function(molecule_name,temp,isot)
-    
-#Begin calculations                                                                                                       
-    afactor=((aup*gup*n_col)/(q*8.*np.pi*(wn0)**3.)) #mks                                                                 
-    efactor=h.value*c.value*eup/(k_B.value*temp)
-    wnfactor=h.value*c.value*wn0/(k_B.value*temp)
-    phia=1./(deltav*np.sqrt(2.0*np.pi))
-    efactor2=hitran_data['eup_k']/temp
-    efactor1=hitran_data['elower']*1.e2*h.value*c.value/k_B.value/temp
-    tau0=afactor*(np.exp(-1.*efactor1)-np.exp(-1.*efactor2))*phia  #Avoids numerical issues at low T
-    w0=1.e6/wn0
-
-    dvel=0.1e0    #km/s
-    nvel=1001
-    vel=(dvel*(np.arange(0,nvel)-500.0))*1.e3     #now in m/s   
-
-    omega=area/(d_pc*pc.value)**2.
-    fthin=aup*gup*n_col*h.value*c.value*wn0/(q*4.*np.pi)*np.exp(-efactor)*omega # Energy/area/time, mks                   
-
-#Now loop over transitions and velocities to calculate flux                                                               
-    nlines=np.size(tau0)
-    tau=np.zeros([nlines,nvel])
-    wave=np.zeros([nlines,nvel])
+
+    wn0 = hitran_data['wn']*1e2 # now m-1
+    aup = hitran_data['a']
+    eup = (hitran_data['elower']+hitran_data['wn'])*1e2 #now m-1
+    gup = hitran_data['gp']
+
+    #Compute partition function
+    q = _compute_partition_function(molecule_name,temp,isot)
+
+    #Begin calculations
+    afactor = ((aup*gup*n_col)/(q*8.*np.pi*(wn0)**3.)) #mks
+    efactor = h.value*c.value*eup/(k_B.value*temp)
+    wnfactor = h.value*c.value*wn0/(k_B.value*temp)
+    phia = 1./(deltav*np.sqrt(2.0*np.pi))
+    efactor2 = hitran_data['eup_k']/temp
+    efactor1 = hitran_data['elower']*1.e2*h.value*c.value/k_B.value/temp
+    tau0 = afactor*(np.exp(-1.*efactor1)-np.exp(-1.*efactor2))*phia  #Avoids numerical issues at low T
+
+    dvel = deltav/oversamp    #m/s
+    nvel = 10*oversamp+1 #5 sigma window
+    vel = (dvel*(np.arange(0,nvel)-(nvel-1)/2))
+
+    omega = area/(d_pc*pc.value)**2.
+    fthin = aup*gup*n_col*h.value*c.value*wn0/(q*4.*np.pi)*np.exp(-efactor)*omega # Energy/area/time, mks
+
+    #Now loop over transitions and velocities to calculate flux
+    nlines = np.size(tau0)
+    tau = np.zeros([nlines,nvel])
+    wave = np.zeros([nlines,nvel])
     for ha,mytau in enumerate(tau0):
-        for ka, myvel in enumerate(vel):
-            tau[ha,ka]=tau0[ha]*np.exp(-vel[ka]**2./(2.*deltav**2.))
-            wave[ha,ka]=1.e6/wn0[ha]*(1+vel[ka]/c.value)
-#Now interpolate over wavelength space so that all lines can be added together                                            
-    w_arr=wave            #nlines x nvel                                                                                  
-    f_arr=w_arr-w_arr     #nlines x nvel                                                                                  
-    nbins=(wmax-wmin)/res
-#Create arrays to hold full spectrum (optical depth vs. wavelength)
-    totalwave=np.arange(nbins)*(wmax-wmin)/nbins+wmin
-    totaltau=np.zeros(np.size(totalwave))
+        tau[ha,:] = tau0[ha]*np.exp(-vel**2./(2.*deltav**2.))
+        wave[ha,:] = 1.e6/wn0[ha]*(1+vel/c.value)
 
-#Create array to hold line fluxes (one flux value per line)
-    lineflux=np.zeros(nlines)
+    #Now interpolate over wavelength space so that all lines can be added together
+    w_arr = wave            #nlines x nvel
+    f_arr = w_arr-w_arr     #nlines x nvel
+    nbins = int(oversamp*(wmax-wmin)/wmax*(c.value/deltav))
+
+    #Create arrays to hold full spectrum (optical depth vs. wavelength)
+    totalwave = np.logspace(np.log10(wmin-10*deltav/c.value*wmax),np.log10(wmax+10*deltav/c.value*wmax),nbins) #Extend beyond input wave by 10xdelta_wave
+    totaltau = np.zeros(nbins)
+
+    #Create array to hold line fluxes (one flux value per line)
+    lineflux = np.zeros(nlines)
+    totalwave_index = np.arange(totalwave.size)
+    index_interp = interp1d(totalwave,totalwave_index)
     for i in range(nlines):
-        w=np.where((totalwave > np.min(wave[i,:])) & (totalwave < np.max(wave[i,:])))
+
+        minw = np.min(wave[i,:])
+        maxw = np.max(wave[i,:])
+        minindex = int(index_interp(minw))
+        maxindex = int(index_interp(maxw))
+
+        w = np.arange(minindex,maxindex)
+
         if(np.size(w) > 0):
-            newtau=np.interp(totalwave[w],wave[i,:], tau[i,:])
-            totaltau[w]+=newtau
-            f_arr[i,:]=2*h.value*c.value*wn0[i]**3./(np.exp(wnfactor[i])-1.0e0)*(1-np.exp(-tau[i,:]))*si2jy*omega
-            lineflux_jykms=np.sum(f_arr[i,:])*dvel
-            lineflux[i]=lineflux_jykms*1e-26*1.*1e5*(1./(w0[i]*1e-4))    #mks
-
-    wave_arr=wave
-    wn=1.e6/totalwave                                         #m^{-1}                                                     
-    wnfactor=h.value*c.value*wn/(k_B.value*temp)
-    flux=2*h.value*c.value*wn**3./(np.exp(wnfactor)-1.0e0)*(1-np.exp(-totaltau))*si2jy*omega
-
-    wave=totalwave
-    #convol_fwhm should be set to FWHM of convolution kernel, in km/s                                                          
-    convolflux=np.copy(flux)
+            newtau = np.interp(totalwave[w],wave[i,:], tau[i,:])
+            totaltau[w] += newtau
+            f_arr[i,:] = 2*h.value*c.value*wn0[i]**3./(np.exp(wnfactor[i])-1.0e0)*(1-np.exp(-tau[i,:]))*omega
+            lineflux[i] = np.sum(f_arr[i,:]) * (dvel/c.value) * (c.value*wn0[i]) #in W/m2
+
+    wave_arr = wave
+    wn = 1.e6/totalwave                                         #m^{-1}
+    wnfactor = h.value*c.value*wn/(k_B.value*temp)
+    flux = 2*h.value*c.value*wn**3./(np.exp(wnfactor)-1.0e0)*(1-np.exp(-totaltau))*si2jy*omega
+
+    wave = totalwave
+
+    #convol_fwhm should be set to FWHM of convolution kernel, in km/s
+    convolflux = np.copy(flux)
     if(convol_fwhm is not None):
-        convolflux=spec_convol(wave,flux,convol_fwhm)
+        convolflux = spec_convol(wave,flux,convol_fwhm)
 
     slabdict={}
 
-#Line params
-    hitran_data['lineflux']=lineflux
-    hitran_data['tau_peak']=tau0
-    hitran_data['fthin']=fthin
-    hitran_data=_convert_quantum_strings(hitran_data)
-    hitran_data=_strip_superfluous_hitran_data(hitran_data)
-    slabdict['lineparams']=hitran_data
+    #Line params
+    hitran_data['lineflux'] = lineflux
+    hitran_data['tau_peak'] = tau0
+    hitran_data['fthin'] = fthin
+    hitran_data = _convert_quantum_strings(hitran_data)
+    hitran_data = _strip_superfluous_hitran_data(hitran_data)
+    slabdict['lineparams'] = hitran_data
 
-#Line flux array
+    #Line flux array
     lines={'flux_arr':f_arr , 'wave_arr':wave_arr , 'velocity':vel*1e-3}
-    slabdict['lines']=lines
+    slabdict['lines'] = lines
 
-#Spectrum
+    #Spectrum
     spectrum_table = Table([wave, flux, convolflux, totaltau], names=('wave', 'flux', 'convolflux','totaltau'),  dtype=('f8', 'f8', 'f8','f8'))
     spectrum_table['wave'].unit = 'micron'
     spectrum_table['flux'].unit = 'Jy'
     spectrum_table['convolflux'].unit = 'Jy'
     slabdict['spectrum']=spectrum_table
 
-#Model params
+    #Model params
     if(convol_fwhm is not None):
         convol_fwhm=convol_fwhm*un.km/un.s
-    modelparams_table={'area':area*un.meter*un.meter,'temp':temp*un.K,'n_col':n_col/un.meter/un.meter, 'res':res*un.micron, 
+    modelparams_table={'area':area*un.meter*un.meter,'temp':temp*un.K,'n_col':n_col/un.meter/un.meter, 
                        'deltav':deltav*un.meter/un.s, 'convol_fwhm':convol_fwhm, 'd_pc':d_pc*un.parsec,
                        'isotopologue_number':isot,'molecule_name':molecule_name}
-    slabdict['modelparams']=modelparams_table
+    slabdict['modelparams'] = modelparams_table
 
     return slabdict
 
 
 def _compute_partition_function(molecule_name,temp,isotopologue_number=1):
-    '''                                                                                                                                       
+    '''
     For a given input molecule name, isotope number, and temperature, return the partition function Q
-                                                                                                                                              
-    Parameters                                                                                                                                
-    ----------                                                                                                                                
+
+    Parameters
+    ----------
     molecule_name : string
         The molecule name string (e.g., 'CO', 'H2O')
     temp : float
         The temperature at which to compute the partition function
     isotopologue_number : float, optional
         Isotopologue number, with 1 being most common, etc. Defaults to 1.
 
-    Returns                                                                                                                                   
-    -------                                                                                                                                   
+    Returns
+    -------
     q : float
       The partition function
     '''
 
-    exomol_pf_dict={200:'https://www.exomol.com/db/SiO/28Si-16O/SiOUVenIR/28Si-16O__SiOUVenIR.pf'}
+    exomol_pf_dict = {200:'https://www.exomol.com/db/SiO/28Si-16O/SiOUVenIR/28Si-16O__SiOUVenIR.pf'}
 
-    G=get_global_identifier(molecule_name, isotopologue_number=isotopologue_number)
+    G = get_global_identifier(molecule_name, isotopologue_number=isotopologue_number)
     if(G<200):  #in HITRAN database
-        qurl='https://hitran.org/data/Q/'+'q'+str(G)+'.txt'
+        qurl = 'https://hitran.org/data/Q/'+'q'+str(G)+'.txt'
     if(G>=200):  #presumed to be in exomol
-        qurl=exomol_pf_dict[G]
+        qurl = exomol_pf_dict[G]
 
     handle = urllib.request.urlopen(qurl)
     print('Reading partition function from: ',qurl)
     qdata = pd.read_csv(handle,sep=' ',skipinitialspace=True,names=['temp','q'],header=None)
 
 #    pathmod=os.path.dirname(__file__)
 #    if not os.path.exists(qfilename):  #download data from internet
        #get https://hitran.org/data/Q/qstr(G).txt
 
-    q=np.interp(temp,qdata['temp'],qdata['q'])
+    q = np.interp(temp,qdata['temp'],qdata['q'])
     return q
 
+def write_slab(slabdict,filename='slabmodel.fits'):
+    '''
+    Write the slab model to a fits file.
+
+    Parameters
+    ----------
+    slabdict : Dictionary
+        Dictionary as output by slabspec
+    filename : String
+        Name of output fits file
+
+    Returns
+    -------
+    '''
+
+    wave = slabdict['spectrum']['wave']
+    flux = slabdict['spectrum']['convolflux']
+
+    c1 = fits.Column(name='wave', array=wave, format='F')
+    c2 = fits.Column(name='flux', array=flux, format='F')
+    t1 = fits.BinTableHDU.from_columns([c1, c2])
+
+    moldata = slabdict['lineparams']
+    mol_cols = []
+    for key in moldata.keys():
+        try:
+            mol_cols.append(fits.Column(name=key,array=moldata[key],format='F'))
+        except:
+            mol_cols.append(fits.Column(name=key,array=moldata[key],format='A'))
+    t2 = fits.BinTableHDU.from_columns(mol_cols)
+
+    primary = fits.PrimaryHDU()
+    hdulist = fits.HDUList([primary,t1,t2])
+
+    hdulist.writeto(filename,overwrite=True)
```

## spectools_ir/utils/utils.py

```diff
@@ -2,53 +2,58 @@
 
 from numpy import uint,float64,float32
 import os as os
 from astroquery.hitran import Hitran
 
 from astropy import units as un
 from astropy.constants import c, k_B, h, u
-from astropy.convolution import Gaussian1DKernel, convolve
+from astropy.convolution import Gaussian1DKernel, convolve_fft
 from astropy.table import Table
 
 import matplotlib.pyplot as plt
 import matplotlib as matplotlib
 import sys as sys
 
 def make_rotation_diagram(lineparams, units='mks', fluxkey='lineflux'):
-    '''                                                                                                     
-    Take ouput of make_spec and use it to compute rotation diagram parameters.                              
-                                                                                                            
-    Parameters                                                                                              
-    ---------                                                                                               
-    lineparams: dictionary                                                                                  
-        dictionary output from make_spec                                                                    
+    '''
+    Take ouput of make_spec and use it to compute rotation diagram parameters.
+
+    Parameters
+    ---------
+    lineparams: dictionary
+        dictionary output from make_spec
     units : string, optional
         either 'mks', 'cgs' or 'mixed' (all mks, but wavenumber in cm-1)
     fluxkey : string, optional
         name of column in lineparams holding the line flux data
 
-    Returns                                                                                                 
-    --------                                                                                                
-    rot_table: astropy Table                                                                                
-        Table of x and y values for rotation diagram.                                                                                                             
+    Returns
+    --------
+    rot_table: astropy Table
+        Table of x and y values for rotation diagram.
     '''
-
     if('gup' in lineparams.columns):
         gup=lineparams['gup']
 
     if('gp' in lineparams.columns):
         gup=lineparams['gp']
 
     x=lineparams['eup_k']
     y=np.log(lineparams[fluxkey]/(lineparams['wn']*1e2*gup*lineparams['a']))   #All mks
+    dy=lineparams['lineflux_err']/lineparams[fluxkey]
+
     if(units=='cgs'):
         y=np.log(1000.*lineparams[fluxkey]/(lineparams['wn']*gup*lineparams['a'])) #All cgs
     if(units=='mixed'):
         y=np.log(lineparams[fluxkey]/(lineparams['wn']*gup*lineparams['a'])) #Mixed units
-    rot_dict={'x':x,'y':y,'units':units}
+    if ('lineflux_err' in lineparams.columns):
+        dy=lineparams['lineflux_err']/lineparams[fluxkey]
+        rot_dict={'x':x,'y':y,'yerr':dy,'units':units}
+    else: 
+        rot_dict={'x':x,'y':y,'units':units}
 
     return rot_dict
 
 
 def compute_thermal_velocity(molecule_name, temp, isotopologue_number=1):
     '''
     Compute the thermal velocity given a molecule name and temperature
@@ -112,15 +117,15 @@
     sigma : float
        sigma of Gaussian distribution
 
     Returns
     ----------
     fwhm : float
        Full Width at Half Maximum of Gaussian distribution
-    '''                        
+    '''
     return  sigma*(2.*np.sqrt(2.*np.log(2.)))
 
 def fwhm_to_sigma(fwhm):
     '''
     Convert fwhm to sigma
 
     Parameters
@@ -128,60 +133,60 @@
     fwhm : float
        Full Width at Half Maximum of Gaussian distribution
 
     Returns
     ----------
     sigma : float
        sigma of Gaussian distribution
-    '''                        
+    '''
 
     return fwhm/(2.*np.sqrt(2.*np.log(2.)))
 
 def wn_to_k(wn):
-    '''                        
+    '''
     Convert wavenumber to Kelvin
 
     Parameters
     ----------
     wn : AstroPy quantity
        Wavenumber including units
 
     Returns
     ---------
     energy : AstroPy quantity
        Energy of photon with given wavenumber
 
-    '''              
+    '''
     return wn.to(1/un.m)*h*c/k_B
 
 def extract_hitran_data(molecule_name, wavemin, wavemax, isotopologue_number=1, eupmax=None, aupmin=None,swmin=None,vup=None):
-    '''                                                               
-    Extract data from HITRAN 
+    '''
+    Extract data from HITRAN
     Primarily makes use of astroquery.hitran, with some added functionality specific to common IR spectral applications
-    Parameters 
-    ---------- 
+    Parameters
+    ----------
     molecule_name : string
         String identifier for molecule, for example, 'CO', or 'H2O'
     wavemin: float
         Minimum wavelength of extracted lines (in microns)
     wavemax: float
-        Maximum wavelength of extracted lines (in microns)                   
+        Maximum wavelength of extracted lines (in microns)
     isotopologue_number : float, optional
         Number representing isotopologue (1=most common, 2=next most common, etc.)
     eupmax : float, optional
         Maximum extracted upper level energy (in Kelvin)
     aupmin : float, optional
         Minimum extracted Einstein A coefficient
     swmin : float, optional
         Minimum extracted line strength
     vup : float, optional
         Can be used to selet upper level energy.  Note: only works if 'Vp' string is a single number.
 
     Returns
-    ------- 
+    -------
     hitran_data : astropy table
         Extracted data
     '''
 
     #Convert molecule name to number
     M = get_molecule_identifier(molecule_name)
 
@@ -203,15 +208,15 @@
     tbl.rename_column('local_upper_quanta','Qp')
     tbl.rename_column('local_lower_quanta','Qpp')
 
     #Extract desired portion of dataset
     ebool = np.full(np.size(tbl), True, dtype=bool)  #default to True
     abool = np.full(np.size(tbl), True, dtype=bool)  #default to True
     swbool = np.full(np.size(tbl), True, dtype=bool)  #default to True
-    vupbool = np.full(np.size(tbl), True, dtype=bool)  #default to True                                                            
+    vupbool = np.full(np.size(tbl), True, dtype=bool)  #default to True
     #Upper level energy
     if(eupmax is not None):
         ebool = tbl['eup_k'] < eupmax
     #Upper level A coeff
     if(aupmin is not None):
         abool = tbl['a'] > aupmin
     #Line strength
@@ -225,29 +230,29 @@
     extractbool = (abool & ebool & swbool & vupbool)
     hitran_data=tbl[extractbool]
 
     #Return astropy table
     return hitran_data
 
 def get_global_identifier(molecule_name,isotopologue_number=1):
-    '''                                                                                                                                
+    '''
     For a given input molecular formula, return the corresponding HITRAN *global* identifier number.
-    For more info, see https://hitran.org/docs/iso-meta/ 
-                                                                                                                                       
-    Parameters                                                                                                                         
-    ----------                                                                                                                         
-    molecular_formula : str                                                                                                            
-        The string describing the molecule.              
+    For more info, see https://hitran.org/docs/iso-meta/
+
+    Parameters
+    ----------
+    molecular_formula : str
+        The string describing the molecule.
     isotopologue_number : int, optional
-        The isotopologue number, from most to least common.                                                                              
-                                                                                                                                       
-    Returns                                                                                                                            
-    -------                                                                                                                            
-    G : int                                                                                                                            
-        The HITRAN global identifier number.                                                                                        
+        The isotopologue number, from most to least common.
+
+    Returns
+    -------
+    G : int
+        The HITRAN global identifier number.
     '''
 
     mol_isot_code=molecule_name+'_'+str(isotopologue_number)
 
     trans = { 'H2O_1':1, 'H2O_2':2, 'H2O_3':3, 'H2O_4':4, 'H2O_5':5, 'H2O_6':6, 'H2O_7':129,
                'CO2_1':7,'CO2_2':8,'CO2_3':9,'CO2_4':10,'CO2_5':11,'CO2_6':12,'CO2_7':13,'CO2_8':14,
                'CO2_9':121,'CO2_10':15,'CO2_11':120,'CO2_12':122,
@@ -295,71 +300,71 @@
                'HC3N_1':109,
                'H2_1':103,'H2_2':115,
                'CS_1':97,'CS_2':98,'CS_3':99,'CS_4':100,
                'SO3_1':114,
                'C2N2_1':123,
                'COCl2_1':124,'COCl2_2':125,'SiO_1':200}
  #SiO is not in HITRAN, so I just assigned it 200
- 
+
     try:
         return trans[mol_isot_code]
     except KeyError:
         print('The molecule/isot combination ',mol_isot_code,' is not in HITRAN and not covered by this code.')
         raise KeyError
 
 #Code from Nathan Hagen
 #https://github.com/nzhagen/hitran
 def translate_molecule_identifier(M):
-    '''                                                                                                            
-    For a given input molecule identifier number, return the corresponding molecular formula.                      
-                                                                                                                   
-    Parameters                                                                                                     
-    ----------                                                                                                     
-    M : int                                                                                                        
-        The HITRAN molecule identifier number.                                                                     
-                                                                                                                   
-    Returns                                                                                                        
-    -------                                                                                                        
-    molecular_formula : str                                                                                        
-        The string describing the molecule.                                                                        
+    '''
+    For a given input molecule identifier number, return the corresponding molecular formula.
+
+    Parameters
+    ----------
+    M : int
+        The HITRAN molecule identifier number.
+
+    Returns
+    -------
+    molecular_formula : str
+        The string describing the molecule.
     '''
 
     trans = { '1':'H2O',    '2':'CO2',   '3':'O3',      '4':'N2O',   '5':'CO',    '6':'CH4',   '7':'O2',     '8':'NO',
               '9':'SO2',   '10':'NO2',  '11':'NH3',    '12':'HNO3', '13':'OH',   '14':'HF',   '15':'HCl',   '16':'HBr',
              '17':'HI',    '18':'ClO',  '19':'OCS',    '20':'H2CO', '21':'HOCl', '22':'N2',   '23':'HCN',   '24':'CH3Cl',
              '25':'H2O2',  '26':'C2H2', '27':'C2H6',   '28':'PH3',  '29':'COF2', '30':'SF6',  '31':'H2S',   '32':'HCOOH',
              '33':'HO2',   '34':'O',    '35':'ClONO2', '36':'NO+',  '37':'HOBr', '38':'C2H4', '39':'CH3OH', '40':'CH3Br',
              '41':'CH3CN', '42':'CF4',  '43':'C4H2',   '44':'HC3N', '45':'H2',   '46':'CS',   '47':'SO3'}
     return(trans[str(M)])
 
 #Code from Nathan Hagen
 #https://github.com/nzhagen/hitran
 def get_molecule_identifier(molecule_name):
-    '''                                                                                                                                
-    For a given input molecular formula, return the corresponding HITRAN molecule identifier number.                                   
-                                                                                                                                       
-    Parameters                                                                                                                         
-    ----------                                                                                                                         
-    molecular_formula : str                                                                                                            
-        The string describing the molecule.                                                                                            
-                                                                                                                                       
-    Returns                                                                                                                            
-    -------                                                                                                                            
-    M : int                                                                                                                            
-        The HITRAN molecular identifier number.                                                                                        
+    '''
+    For a given input molecular formula, return the corresponding HITRAN molecule identifier number.
+
+    Parameters
+    ----------
+    molecular_formula : str
+        The string describing the molecule.
+
+    Returns
+    -------
+    M : int
+        The HITRAN molecular identifier number.
     '''
 
     trans = { '1':'H2O',    '2':'CO2',   '3':'O3',      '4':'N2O',   '5':'CO',    '6':'CH4',   '7':'O2',     '8':'NO',
               '9':'SO2',   '10':'NO2',  '11':'NH3',    '12':'HNO3', '13':'OH',   '14':'HF',   '15':'HCl',   '16':'HBr',
              '17':'HI',    '18':'ClO',  '19':'OCS',    '20':'H2CO', '21':'HOCl', '22':'N2',   '23':'HCN',   '24':'CH3Cl',
              '25':'H2O2',  '26':'C2H2', '27':'C2H6',   '28':'PH3',  '29':'COF2', '30':'SF6',  '31':'H2S',   '32':'HCOOH',
              '33':'HO2',   '34':'O',    '35':'ClONO2', '36':'NO+',  '37':'HOBr', '38':'C2H4', '39':'CH3OH', '40':'CH3Br',
              '41':'CH3CN', '42':'CF4',  '43':'C4H2',   '44':'HC3N', '45':'H2',   '46':'CS',   '47':'SO3'}
 
-    ## Invert the dictionary.                                                                                                          
+    ## Invert the dictionary.
     trans = {v:k for k,v in trans.items()}
     return(int(trans[molecule_name]))
 
 def _check_hitran(molecule_name):
 
     hitran_list = ['H2O','CO2','O3','N2O','CO','CH4','O2','NO','SO2','NO2','NH3','HNO3','OH','HF','HCl','HBr',
              'HI','ClO','OCS','H2CO','HOCl','N2','HCN','CH3Cl',
@@ -372,184 +377,150 @@
     if(molecule_name in hitran_list):
         return 'HITRAN'
     if(molecule_name in exomol_list):
         return 'exomol'
     else:
         return None
 
-def spec_convol(wave, flux, dv):
-    '''                                                                                                             
-    Convolve a spectrum, given wavelength in microns and flux density, by a given FWHM in velocity                  
-                                                                                                                    
-    Parameters                                                                                                      
-    ---------                                                                                                       
-    wave : numpy array                                                                                              
-        wavelength values, in microns                                                                               
-    flux : numpy array                                                                                              
-        flux density values, in units of Energy/area/time/Hz                                                        
-    dv : float                                                                                                      
-        FWHM of Gaussian convolution kernel, in km/s                                                                         
-                                                                                                                    
-    Returns                                                                                                         
-    --------                                                                                                        
-    newflux : numpy array                                                                                           
-        Convolved spectrum flux density values, in same units as input                                              
-                                                                                                                    
-    '''
-
-#Program assumes units of dv are km/s, and dv=FWHM                                                                 \
-                                                                                                                    
-    dv=fwhm_to_sigma(dv)
-    n=round(4.*dv/(c.value*1e-3)*np.median(wave)/(wave[1]-wave[0]))
-    if (n < 10):
-        n=10.
-
-#Pad arrays to deal with edges                                                                                     \
-
-    dwave=wave[1]-wave[0]
-    wave_low=np.arange(wave[0]-dwave*n, wave[0]-dwave, dwave)
-    wave_high=np.arange(np.max(wave)+dwave, np.max(wave)+dwave*(n-1.), dwave)
-    nlow=np.size(wave_low)
-    nhigh=np.size(wave_high)
-    flux_low=np.zeros(nlow)
-    flux_high=np.zeros(nhigh)
-    mask_low=np.zeros(nlow)
-    mask_high=np.zeros(nhigh)
-    mask_middle=np.ones(np.size(wave))
-    wave=np.concatenate([wave_low, wave, wave_high])
-    flux=np.concatenate([flux_low, flux, flux_high])
-    mask=np.concatenate([mask_low, mask_middle, mask_high])
-
-    newflux=np.copy(flux)
-
-    if( n > (np.size(wave)-n)):
-        print("Your wavelength range is too small for your kernel")
-        print("Program will return an empty array")
-
-    for i in np.arange(n, np.size(wave)-n+1):
-        lwave=wave[np.int(i-n):np.int(i+n+1)]
-        lflux=flux[np.int(i-n):np.int(i+n+1)]
-        lvel=(lwave-wave[np.int(i)])/wave[np.int(i)]*c.value*1e-3
-#        nvel=(np.max(lvel)-np.min(lvel))/(dv*.2) +3
-#        vel=np.arange(nvel)
-#        vel=.2*dv*(vel-np.median(vel))
-        wkernel=markgauss(lvel,mean=0,sigma=dv,area=1.)
-#        wkernel=np.interp(lvel,vel,kernel)                 
-        wkernel=wkernel/np.nansum(wkernel)
-        newflux[np.int(i)]=np.nansum(lflux*wkernel)/np.nansum(wkernel[np.isfinite(lflux)])
-        #Note: denominator is necessary to correctly account for NaN'd regions                                     \
-                                                                                                                    
-
-#Remove NaN'd regions                                                                                              \
-                                                                                                                    
-    nanbool=np.invert(np.isfinite(flux))   #Places where flux is not finite                                        \
-                                                                                                                    
-    newflux[nanbool]='NaN'
-
-#Now remove padding                                                                                                \
-                                                                                                                    
-    newflux=newflux[mask==1]
+def spec_convol(wave,flux,dv):
+    '''
+    Convolve a spectrum, given wavelength in microns and flux density, by a given resolving power
 
-    return newflux
+    Parameters
+    ---------
+    wave : numpy array
+        wavelength values, in microns
+    flux : numpy array
+        flux density values, in units of Energy/area/time/Hz
+    dv : float
+        Resolving power in km/s
+
+    Returns
+    --------
+    newflux : numpy array
+        Convolved spectrum flux density values, in same units as input
 
-def spec_convol_R(wave, flux, R):
-    '''                                                                                                                        
-    Convolve a spectrum, given wavelength in microns and flux density, by a given wavelength-dependent R                             
-                                                                                                                               
-    Parameters                                                                                                                 
-    ---------                                                                                                                  
-    wave : numpy array                                                                                                         
-        wavelength values, in microns                                                                                          
-    flux : numpy array                                                                                                         
-        flux density values, in units of Energy/area/time/Hz                                                                   
-    R : numpy array                                                                                                                  
-        Resolving power (lambda / dlambda)                                                                                     
-                                                                                                                               
-    Returns                                                                                                                    
-    --------                                                                                                                   
-    newflux : numpy array                                                                                                      
-        Convolved spectrum flux density values, in same units as input                                                         
-                                                                                                                               
     '''
-    # find the minimum spacing between wavelengths in the dataset                                                              
+    R = c.value/(dv*1e3) #input dv in km/s, convert to m/s
+    # find the minimum spacing between wavelengths in the dataset
     dws = np.abs(wave - np.roll(wave, 1))
-    dw_min = np.min(dws)   #Minimum delta-wavelength between points in dataset                                                 
+    dw_min = np.min(dws)   #Minimum delta-wavelength between points in dataset
 
-    fwhm = wave / R  # FWHM of resolution element as a function of wavelength ("delta lambda" in same units as wave)           
-    #fwhm / dw_min gives FWHM values expressed in units of minimum spacing, or the sampling for each wavelength                
-    #(sampling is sort of the number of data points per FWHM)                                                                  
-    #The sampling is different for each point in the wavelength array, because the FWHM is wavelength dependent                
-    #fwhm_s then gives the minimum value of the sampling - the most poorly sampled wavelength.                                 
-    fwhm_s = np.min(fwhm / dw_min)  # find mininumvalue of sampling for this dataset                                           
-    # but do not allow the sampling FWHM to be less than Nyquist                                                               
-    # (i.e., make sure there are at least two points per resolution element)                                                   
-    fwhm_s = np.max([2., fwhm_s])  #Will return 2 only if fwhm_s is less than 2                                                
-    #If you want all wavelengths to have the same sampling per resolution element,                                             
-    #then this ds gives the wavelength spacing for each wavelength (in units of wavelength)                                    
+    fwhm = wave / R  # FWHM of resolution element as a function of wavelength ("delta lambda" in same units as wave)
+    #fwhm / dw_min gives FWHM values expressed in units of minimum spacing, or the sampling for each wavelength
+    #(sampling is sort of the number of data points per FWHM)
+    #The sampling is different for each point in the wavelength array, because the FWHM is wavelength dependent
+    #fwhm_s then gives the minimum value of the sampling - the most poorly sampled wavelength.
+    fwhm_s = np.min(fwhm / dw_min)  # find mininumvalue of sampling for this dataset
+    # but do not allow the sampling FWHM to be less than Nyquist
+    # (i.e., make sure there are at least two points per resolution element)
+    fwhm_s = np.max([2., fwhm_s])  #Will return 2 only if fwhm_s is less than 2
+    #If you want all wavelengths to have the same sampling per resolution element,
+    #then this ds gives the wavelength spacing for each wavelength (in units of wavelength)
     ds = fwhm / fwhm_s
-    # use the min wavelength as a starting point                                                                               
-    w = np.min(wave)
-    #Initialize array to hold new wavelength values                                                                            
-    #Note: it's much faster (~50%) to append to lists than np.array()'s                                                        
-    wave_constfwhm = []
-
-
-    # doing this as a loop is slow, but straightforward.                                                                       
-    while w < np.max(wave):
-        # use interpolation to get delta-wavelength from the sampling as a function of wavelength.                             
-        # this method is over 5x faster than the original use of scipy.interpolate.interp1d.                                   
-        w += np.interp(w,wave,ds)  #Get value of ds at w, then add to old value of w                                           
-        wave_constfwhm.append(w)
 
-    wave_constfwhm.pop()  # remove last point which is an extrapolation                                                        
-    wave_constfwhm = np.array(wave_constfwhm)  #Convert list to numpy array                                                    
+    wave_constfwhm = np.cumsum(ds)+np.min(wave)
 
-    # interpolate the flux onto the new wavelength set                                                                         
+    # interpolate the flux onto the new wavelength set
     flux_constfwhm = np.interp(wave_constfwhm,wave,flux)
 
-    # convolve the flux with a gaussian kernel; first convert the FWHM to sigma                                                
+    # convolve the flux with a gaussian kernel; first convert the FWHM to sigma
     sigma_s = fwhm_s / 2.3548
     try:
-        # for astropy < 0.4                                                                                                    
+        # for astropy < 0.4
         g = Gaussian1DKernel(width=sigma_s)
     except TypeError:
-        # for astropy >= 0.4                                                                                                   
+        # for astropy >= 0.4
         g = Gaussian1DKernel(sigma_s)
-    # use boundary='extend' to set values outside the array to nearest array value.                                            
-    # this is the best approximation in this case.                                                                             
-    flux_conv = convolve(flux_constfwhm, g, normalize_kernel=True, boundary='extend')
+    # use boundary='extend' to set values outside the array to nearest array value.
+    # this is the best approximation in this case.
+    flux_conv = convolve_fft(flux_constfwhm, g, normalize_kernel=True, boundary='fill')
+    flux_oldsampling = np.interp(wave, wave_constfwhm, flux_conv)
+
+    return flux_oldsampling
+
+def spec_convol_R(wave, flux, R):
+    '''
+    Convolve a spectrum, given wavelength in microns and flux density, by a given wavelength-dependent R
+
+    Parameters
+    ---------
+    wave : numpy array
+        wavelength values, in microns
+    flux : numpy array
+        flux density values, in units of Energy/area/time/Hz
+    dv : numpy array
+        Resolving power in km/s
+
+    Returns
+    --------
+    newflux : numpy array
+        Convolved spectrum flux density values, in same units as input
+
+    '''
+    # find the minimum spacing between wavelengths in the dataset
+    dws = np.abs(wave - np.roll(wave, 1))
+    dw_min = np.min(dws)   #Minimum delta-wavelength between points in dataset
+
+    fwhm = wave / R  # FWHM of resolution element as a function of wavelength ("delta lambda" in same units as wave)
+    #fwhm / dw_min gives FWHM values expressed in units of minimum spacing, or the sampling for each wavelength
+    #(sampling is sort of the number of data points per FWHM)
+    #The sampling is different for each point in the wavelength array, because the FWHM is wavelength dependent
+    #fwhm_s then gives the minimum value of the sampling - the most poorly sampled wavelength.
+    fwhm_s = np.min(fwhm / dw_min)  # find mininumvalue of sampling for this dataset
+    # but do not allow the sampling FWHM to be less than Nyquist
+    # (i.e., make sure there are at least two points per resolution element)
+    fwhm_s = np.max([2., fwhm_s])  #Will return 2 only if fwhm_s is less than 2
+    #If you want all wavelengths to have the same sampling per resolution element,
+    #then this ds gives the wavelength spacing for each wavelength (in units of wavelength)
+    ds = fwhm / fwhm_s
+
+    wave_constfwhm = np.cumsum(ds)+np.min(wave)
+    # interpolate the flux onto the new wavelength set
+    flux_constfwhm = np.interp(wave_constfwhm,wave,flux)
+
+    # convolve the flux with a gaussian kernel; first convert the FWHM to sigma
+    sigma_s = fwhm_s / 2.3548
+    try:
+        # for astropy < 0.4
+        g = Gaussian1DKernel(width=sigma_s)
+    except TypeError:
+        # for astropy >= 0.4
+        g = Gaussian1DKernel(sigma_s)
+    # this is the best approximation in this case.
+    flux_conv = convolve_fft(flux_constfwhm, g, normalize_kernel=True, boundary='fill')
     flux_oldsampling = np.interp(wave, wave_constfwhm, flux_conv)
 
     return flux_oldsampling
 
 
 def get_molmass(molecule_name,isotopologue_number=1):
     '''                                                                                                                          \
-                                                                                                                                  
-    For a given input molecular formula, return the corresponding molecular mass, in amu                                          
+
+    For a given input molecular formula, return the corresponding molecular mass, in amu
                                                                                                                                  \
-                                                                                                                                  
+
     Parameters                                                                                                                   \
-                                                                                                                                  
+
     ----------                                                                                                                   \
-                                                                                                                                  
+
     molecular_formula : str                                                                                                      \
-        The string describing the molecule.                                                                                       
-    isotopologue_number : int, optional                                                                                           
+        The string describing the molecule.
+    isotopologue_number : int, optional
         The isotopologue number, from most to least common.                                                                      \
-                                                                                                                                  
+
     Returns                                                                                                                      \
-                                                                                                                                  
+
     -------                                                                                                                      \
     mu : float                                                                                                                   \
-        Molecular mass in amu                                                                                                     
+        Molecular mass in amu
     '''
 
     mol_isot_code=molecule_name+'_'+str(isotopologue_number)
-#https://hitran.org/docs/iso-meta/                                                                                                
+#https://hitran.org/docs/iso-meta/
 
     mass = { 'H2O_1':18.010565, 'H2O_2':20.014811, 'H2O_3':19.01478, 'H2O_4':19.01674,
                'H2O_5':21.020985, 'H2O_6':20.020956, 'H2O_7':20.022915,
                'CO2_1':43.98983,'CO2_2':44.993185,'CO2_3':45.994076,'CO2_4':44.994045,
                'CO2_5':46.997431,'CO2_6':45.9974,'CO2_7':47.998322,'CO2_8':46.998291,
                'CO2_9':45.998262,'CO2_10':49.001675,'CO2_11':48.001646,'CO2_12':47.0016182378,
                'O3_1':47.984745,'O3_2':49.988991,'O3_3':49.988991,'O3_4':48.98896,'O3_5':48.98896,
@@ -601,36 +572,36 @@
                'COCl2_1':97.9326199796,'COCl2_2':99.9296698896,
                'CS2_1':75.94414,'CS2_2':77.93994,'CS2_3':76.943256,'CS2_4':76.947495,'SiO_1':44.0845}
 
     return mass[mol_isot_code]
 
 
 def get_miri_mrs_resolution(subband, wavelength):
-    '''                                                                                                                        
-    Retrieve approximate MIRI MRS spectral resolution given a wavelength                                                       
-                                                                                                                               
-    Parameters                                                                                                                 
-                                                                                                                               
-    ---------                                                                                                                  
-    subband: string                                                                                                            
-      Subband (1A, 1B, ...4C)                                                                                                  
-                                                                                                                               
-    wavelength: float                                                                                                          
-      Wavelength in microns                                                                                                    
-                                                                                                                               
-    Returns                                                                                                                    
-                                                                                                                               
-    ---------                                                                                                                  
-    R: float                                                                                                                   
-      Spectral resolution                                                                                                      
-                                                                                                                               
+    '''
+    Retrieve approximate MIRI MRS spectral resolution given a wavelength
+
+    Parameters
+
+    ---------
+    subband: string
+      Subband (1A, 1B, ...4C)
+
+    wavelength: float
+      Wavelength in microns
+
+    Returns
+
+    ---------
+    R: float
+      Spectral resolution
+
     '''
     wavelength=np.array(wavelength)
 
-    #Define spectral resolution dictionaries.  Table 1 of Wells et al. MIRI paper                                              
+    #Define spectral resolution dictionaries.  Table 1 of Wells et al. MIRI paper
     w0={
         "1A":4.87,
         "1B":5.62,
         "1C":6.49,
         "2A":7.45,
         "2B":8.61,
         "2C":9.91,
@@ -776,15 +747,15 @@
     y_4a = [get_miri_mrs_resolution('4A',myx) for myx in x_4a]
 
     x_4b=np.linspace(20.44,24.72,num=50)
     y_4b = [get_miri_mrs_resolution('4B',myx) for myx in x_4b]
 
     x_4c=np.linspace(23.84,28.82,num=50)
     y_4c = [get_miri_mrs_resolution('4C',myx) for myx in x_4c]
-   
+
     fig=plt.figure(figsize=figsize)
     ax1=fig.add_subplot(111)
     ax1.plot(x_1a,y_1a,label='1A')
     ax1.plot(x_1b,y_1b,label='1B')
     ax1.plot(x_1c,y_1c,label='1C')
     ax1.plot(x_2a,y_2a,label='2A')
     ax1.plot(x_2b,y_2b,label='2B')
@@ -803,31 +774,31 @@
     ax1.set_xticks([5,6,7,8,9,10,20])
     ax1.get_xaxis().set_major_formatter(matplotlib.ticker.ScalarFormatter())
     ax1.set_xlabel('Wavelength [$\mu$m]',fontsize=18)
     ax1.set_ylabel('Resolution (R)',fontsize=18)
     plt.show()
     return
 
-#Modification of code from Nathan Hagen 
-#https://github.com/nzhagen/hitran  
-def extract_hitran_from_par(filename,wavemin=None,wavemax=None,isotopologue_number=1,eupmax=None,aupmin=None,swmin=None,vup=None): 
+#Modification of code from Nathan Hagen
+#https://github.com/nzhagen/hitran
+def extract_hitran_from_par(filename,wavemin=None,wavemax=None,isotopologue_number=1,eupmax=None,aupmin=None,swmin=None,vup=None):
     '''
     Given a HITRAN2012-format text file, read in the parameters of the molecular absorption features.
 
     Paramters
     ---------
     filename : str
        The filename to read in.
 
     Return
     ------
     data : astropy table
         The table of HITRAN data for the molecule
     ----
-  
+
     '''
     if not os.path.exists:
         raise ImportError('The input filename"' + filename + '" does not exist.')
 
     if filename.endswith('.zip'):
         import zipfile
         zip = zipfile.ZipFile(filename, 'r')
@@ -898,25 +869,25 @@
         data['iref3'].append(line[137:139])
         data['iref4'].append(line[139:141])
         data['iref5'].append(line[141:143])
         data['iref6'].append(line[143:145])
         data['line_mixing_flag'].append(line[145])
         data['gp'].append(float32(line[146:153]))
         data['gpp'].append(float32(line[153:160]))
-    
+
     data=Table(data)  #convert to astropy table
     data['nu']=data['wn']*c.cgs.value   #Now actually frequency of transition
     data['eup_k']=(wn_to_k((data['wn']+data['elower'])/un.cm)).value      #upper level energy in Kelvin
     data['wave']=1.e4/data['wn']       #Wavelength of transition, in microns
 
 
-    #Extract desired portion of dataset                                                                                 
-    ebool = np.full(np.size(data), True, dtype=bool)  #default to True                                                   
-    abool = np.full(np.size(data), True, dtype=bool)  #default to True                                                   
-    swbool = np.full(np.size(data), True, dtype=bool)  #default to True                                                 
+    #Extract desired portion of dataset
+    ebool = np.full(np.size(data), True, dtype=bool)  #default to True
+    abool = np.full(np.size(data), True, dtype=bool)  #default to True
+    swbool = np.full(np.size(data), True, dtype=bool)  #default to True
     vupbool = np.full(np.size(data), True, dtype=bool)  #default to True
     waveminbool = np.full(np.size(data), True, dtype=bool)  #default to True
     wavemaxbool = np.full(np.size(data), True, dtype=bool)  #default to True
 
     #Isotope number
     isobool = (data['local_iso_id'] == isotopologue_number)
     #Upper level energy
@@ -936,17 +907,16 @@
     if(wavemin is not None):
         waveminbool=data['wave'] > wavemin
     #wavemax
     if(wavemax is not None):
         wavemaxbool=data['wave'] < wavemax
 
     #Combine
-    extractbool = (abool & ebool & swbool & vupbool &waveminbool & wavemaxbool & isobool)
+    extractbool = (abool & ebool & swbool & vupbool & waveminbool & wavemaxbool & isobool)
     hitran_data=data[extractbool]
 
     if filename.endswith('.zip'):
         zip.close()
     else:
         filehandle.close()
 
     return(hitran_data)
-
```

## Comparing `spectools_ir-0.2.0.dist-info/LICENSE` & `spectools_ir-1.0.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `spectools_ir-0.2.0.dist-info/METADATA` & `spectools_ir-1.0.0.dist-info/METADATA`

 * *Files 6% similar despite different names*

```diff
@@ -1,14 +1,16 @@
 Metadata-Version: 2.1
 Name: spectools-ir
-Version: 0.2.0
+Version: 1.0.0
 Summary: Tools for analysis and modeling of IR spectra
 Home-page: https://github.com/csalyk/spectools_ir
 Author: Colette Salyk
 Author-email: cosalyk@vassar.edu
+License: UNKNOWN
+Platform: UNKNOWN
 Classifier: Development Status :: 4 - Beta
 Classifier: Intended Audience :: Science/Research
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Operating System :: OS Independent
 Classifier: Programming Language :: Python
 Classifier: Programming Language :: Python :: 3
 Classifier: Topic :: Scientific/Engineering :: Astronomy
@@ -55,7 +57,9 @@
 # Usage
 
 Example usage can be found at https://github.com/csalyk/spectools_ir/ in docs/example.ipynb
 
 # License
 [MIT](https://choosealicense.com/licenses/mit/)
 
+
+
```

## Comparing `spectools_ir-0.2.0.dist-info/RECORD` & `spectools_ir-1.0.0.dist-info/RECORD`

 * *Files 26% similar despite different names*

```diff
@@ -1,20 +1,19 @@
 spectools_ir/__init__.py,sha256=4W8VliAYUP1KY2gLJ_YDy2TmcXYVm-PY7XikQD_bFwA,2
-spectools_ir/flux_calculator/#helpers.py#,sha256=CB5S7Jpl5ykKFHfRimsiCKm6a-8CdOS57-0G4aD8jVQ,8537
 spectools_ir/flux_calculator/__init__.py,sha256=EU6G8CBcVfj6x7vcrzve7XscB2oI3I1davvggg4mdoI,57
-spectools_ir/flux_calculator/flux_calculator.py,sha256=luzujnGXmSEumZY09I-w66xV1Ct2xtUpwX1dQuEUcQY,13931
+spectools_ir/flux_calculator/flux_calculator.py,sha256=LRhcMw-PMOeH0U1kdL9GCKq0OtA3CtUj8knsRjyAi_g,15081
 spectools_ir/flux_calculator/helpers.py,sha256=CB5S7Jpl5ykKFHfRimsiCKm6a-8CdOS57-0G4aD8jVQ,8537
 spectools_ir/slab_fitter/__init__.py,sha256=20ud3eR8BBWMR742rbtnsdo9vHoBL0JE35G8aOWj9nE,217
 spectools_ir/slab_fitter/config.json,sha256=FZmF7Ez9pSeSx7Orlo5kZ_QecbHlErh0oBrQF8RHZ1E,150
 spectools_ir/slab_fitter/helpers.py,sha256=Y-W3frS58Dfm1KHfsH3NLVUyLvb_1uKaSyq81BqepYc,5978
-spectools_ir/slab_fitter/output.py,sha256=9u1j9HQQi96f34z-OM_IXT60pxlF8qgCBKJmbxnTryk,7554
-spectools_ir/slab_fitter/slab_fitter.py,sha256=tWj13djZuZz6M2DIh_QFrhoVZVbPVwNT8mNcnyJS9S8,12255
-spectools_ir/slabspec/__init__.py,sha256=qFmcigI3LQx5duT5lZCc29-epz2IiVcl06Yg-sGW7U8,33
+spectools_ir/slab_fitter/output.py,sha256=_ulQhwTGFN3EzJduhNYALXx-eYtXwM4RFk7ts-g4EQg,7665
+spectools_ir/slab_fitter/slab_fitter.py,sha256=t6NhIXLXBekcXqlNkGMNuUvnVoCvldvETC-4_oDLVh8,12248
+spectools_ir/slabspec/__init__.py,sha256=B_RCEoORXtgCzX_G5_h53yKMSx4egERTNXiQYxQON_w,44
 spectools_ir/slabspec/helpers.py,sha256=ya_qw84_j6u4VnyCdPi3PMIIjrVLOE1UDrWPiEiyreY,4389
-spectools_ir/slabspec/slabspec.py,sha256=5P1A57i3cjlwiUXk0rJz4O1ocfJ3LxiVSrMG20KfErM,14364
+spectools_ir/slabspec/slabspec.py,sha256=iA28zsxAkzajQDDHFL23wrfcqKIVZFgokggjnIgHVr0,10909
 spectools_ir/utils/__init__.py,sha256=TRQibYEEVnl1IihGliF7N6SlYN_q3o4hjOZMKdAd_Oc,414
-spectools_ir/utils/utils.py,sha256=-3qg_dzLMzlBm029IMp8VDCROm9DYFI9YcIYyNyvwYU,48671
-spectools_ir-0.2.0.dist-info/LICENSE,sha256=08HQcYWfCWK4KSPhhE-2MGLMLTTvCBmfINzswde_0bQ,1074
-spectools_ir-0.2.0.dist-info/METADATA,sha256=Umy9Q3h6HaAvEXCC0_1NJ1NEoh1S2-gDR2KrAvoFTPQ,2675
-spectools_ir-0.2.0.dist-info/WHEEL,sha256=U88EhGIw8Sj2_phqajeu_EAi3RAo8-C6zV3REsWbWbs,92
-spectools_ir-0.2.0.dist-info/top_level.txt,sha256=Sg9GfVGIdsoFxHK5j5brcVRKqlfCWNlHmZ_D7a5GNO0,13
-spectools_ir-0.2.0.dist-info/RECORD,,
+spectools_ir/utils/utils.py,sha256=c4ZqNXDya0jShb8VeG9qiLDl-3IcheS9j5DaLw5rGAo,34027
+spectools_ir-1.0.0.dist-info/LICENSE,sha256=08HQcYWfCWK4KSPhhE-2MGLMLTTvCBmfINzswde_0bQ,1074
+spectools_ir-1.0.0.dist-info/METADATA,sha256=mDV0k3uGTW4NO9PzGmOQrvHK7GMDbJC0bmGc3VuqcdE,2712
+spectools_ir-1.0.0.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
+spectools_ir-1.0.0.dist-info/top_level.txt,sha256=Sg9GfVGIdsoFxHK5j5brcVRKqlfCWNlHmZ_D7a5GNO0,13
+spectools_ir-1.0.0.dist-info/RECORD,,
```

