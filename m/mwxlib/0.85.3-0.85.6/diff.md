# Comparing `tmp/mwxlib-0.85.3-py3-none-any.whl.zip` & `tmp/mwxlib-0.85.6-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,24 +1,24 @@
-Zip file size: 161513 bytes, number of entries: 22
--rw-rw-rw-  2.0 fat     2520 b- defN 23-Jun-03 17:04 mwx/__init__.py
--rw-rw-rw-  2.0 fat    44266 b- defN 23-Jun-10 16:10 mwx/controls.py
--rw-rw-rw-  2.0 fat    72480 b- defN 23-Jun-13 15:18 mwx/framework.py
--rw-rw-rw-  2.0 fat    68631 b- defN 23-Jun-05 07:49 mwx/graphman.py
--rw-rw-rw-  2.0 fat    45726 b- defN 23-Jun-10 16:10 mwx/images.py
--rw-rw-rw-  2.0 fat    36017 b- defN 23-Jun-03 17:04 mwx/matplot2.py
--rw-rw-rw-  2.0 fat    68253 b- defN 23-Jun-03 17:04 mwx/matplot2g.py
--rw-rw-rw-  2.0 fat    27598 b- defN 23-Jun-03 17:04 mwx/matplot2lg.py
+Zip file size: 161544 bytes, number of entries: 22
+-rw-rw-rw-  2.0 fat     2520 b- defN 23-Jun-19 10:27 mwx/__init__.py
+-rw-rw-rw-  2.0 fat    44266 b- defN 23-Jun-19 10:28 mwx/controls.py
+-rw-rw-rw-  2.0 fat    72783 b- defN 23-Jun-20 08:58 mwx/framework.py
+-rw-rw-rw-  2.0 fat    68631 b- defN 23-Jun-20 08:11 mwx/graphman.py
+-rw-rw-rw-  2.0 fat    45726 b- defN 23-Jun-19 10:28 mwx/images.py
+-rw-rw-rw-  2.0 fat    36017 b- defN 23-Jun-19 10:27 mwx/matplot2.py
+-rw-rw-rw-  2.0 fat    68253 b- defN 23-Jun-19 10:27 mwx/matplot2g.py
+-rw-rw-rw-  2.0 fat    27598 b- defN 23-Jun-19 10:28 mwx/matplot2lg.py
 -rw-rw-rw-  2.0 fat     6878 b- defN 23-Feb-21 08:50 mwx/mgplt.py
--rw-rw-rw-  2.0 fat   139026 b- defN 23-Jun-13 15:30 mwx/nutshell.py
--rw-rw-rw-  2.0 fat    37369 b- defN 23-Jun-05 06:59 mwx/utilus.py
--rw-rw-rw-  2.0 fat    11670 b- defN 23-Jun-10 12:36 mwx/wxmon.py
--rw-rw-rw-  2.0 fat    19456 b- defN 23-Jun-13 15:30 mwx/wxpdb.py
--rw-rw-rw-  2.0 fat     5254 b- defN 23-Jun-03 17:04 mwx/wxwil.py
--rw-rw-rw-  2.0 fat     8196 b- defN 23-Jun-13 14:18 mwx/wxwit.py
+-rw-rw-rw-  2.0 fat   139029 b- defN 23-Jun-20 01:33 mwx/nutshell.py
+-rw-rw-rw-  2.0 fat    37369 b- defN 23-Jun-20 08:58 mwx/utilus.py
+-rw-rw-rw-  2.0 fat    11175 b- defN 23-Jun-20 08:11 mwx/wxmon.py
+-rw-rw-rw-  2.0 fat    19456 b- defN 23-Jun-19 10:43 mwx/wxpdb.py
+-rw-rw-rw-  2.0 fat     5372 b- defN 23-Jun-20 08:11 mwx/wxwil.py
+-rw-rw-rw-  2.0 fat     8314 b- defN 23-Jun-20 08:11 mwx/wxwit.py
 -rw-rw-rw-  2.0 fat        0 b- defN 23-Jan-23 14:06 mwx/py/__init__.py
--rw-rw-rw-  2.0 fat    16794 b- defN 23-Jun-03 17:04 mwx/py/filling.py
--rw-rw-rw-  2.0 fat     1091 b- defN 23-Jun-13 15:45 mwxlib-0.85.3.dist-info/LICENSE
--rw-rw-rw-  2.0 fat     1893 b- defN 23-Jun-13 15:45 mwxlib-0.85.3.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 23-Jun-13 15:45 mwxlib-0.85.3.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        4 b- defN 23-Jun-13 15:45 mwxlib-0.85.3.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     1609 b- defN 23-Jun-13 15:45 mwxlib-0.85.3.dist-info/RECORD
-22 files, 614823 bytes uncompressed, 159011 bytes compressed:  74.1%
+-rw-rw-rw-  2.0 fat    16794 b- defN 23-Jun-19 10:27 mwx/py/filling.py
+-rw-rw-rw-  2.0 fat     1091 b- defN 23-Jun-20 08:59 mwxlib-0.85.6.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat     1893 b- defN 23-Jun-20 08:59 mwxlib-0.85.6.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 23-Jun-20 08:59 mwxlib-0.85.6.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        4 b- defN 23-Jun-20 08:59 mwxlib-0.85.6.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     1609 b- defN 23-Jun-20 08:59 mwxlib-0.85.6.dist-info/RECORD
+22 files, 614870 bytes uncompressed, 159042 bytes compressed:  74.1%
```

## zipnote {}

```diff
@@ -45,23 +45,23 @@
 
 Filename: mwx/py/__init__.py
 Comment: 
 
 Filename: mwx/py/filling.py
 Comment: 
 
-Filename: mwxlib-0.85.3.dist-info/LICENSE
+Filename: mwxlib-0.85.6.dist-info/LICENSE
 Comment: 
 
-Filename: mwxlib-0.85.3.dist-info/METADATA
+Filename: mwxlib-0.85.6.dist-info/METADATA
 Comment: 
 
-Filename: mwxlib-0.85.3.dist-info/WHEEL
+Filename: mwxlib-0.85.6.dist-info/WHEEL
 Comment: 
 
-Filename: mwxlib-0.85.3.dist-info/top_level.txt
+Filename: mwxlib-0.85.6.dist-info/top_level.txt
 Comment: 
 
-Filename: mwxlib-0.85.3.dist-info/RECORD
+Filename: mwxlib-0.85.6.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## mwx/framework.py

```diff
@@ -1,14 +1,14 @@
 #! python3
 # -*- coding: utf-8 -*-
 """mwxlib framework
 
 Author: Kazuya O'moto <komoto@jeol.co.jp>
 """
-__version__ = "0.85.3"
+__version__ = "0.85.6"
 __author__ = "Kazuya O'moto <komoto@jeol.co.jp>"
 
 from functools import wraps, partial
 from importlib import reload
 import traceback
 import builtins
 import datetime
@@ -431,62 +431,78 @@
     return sizer
 
 
 class Menu(wx.Menu):
     """Construct menu
     
     Args:
-        values : list of MenuItem args
+        menulist : list of MenuItem args
+        owner    : window object to bind handlers
     
     (id, text, hint, style, icon,  ... Menu.Append arguments
        action, updater, highlight) ... Menu Event handlers
     
         - style -> menu style (ITEM_NORMAL, ITEM_CHECK, ITEM_RADIO)
         - icon -> menu icon (bitmap)
         - action -> EVT_MENU handler
         - updater -> EVT_UPDATE_UI handler
         - highlight -> EVT_MENU_HIGHLIGHT handler
     """
-    def __init__(self, owner, values):
+    def __init__(self, owner, menulist):
         wx.Menu.__init__(self)
         self.owner = owner
         
-        for item in values:
+        for item in menulist:
             if not item:
                 self.AppendSeparator()
                 continue
             id = item[0]
             handlers = [x for x in item if callable(x)]
             icons =  [x for x in item if isinstance(x, wx.Bitmap)]
             argv = [x for x in item if x not in handlers and x not in icons]
             if isinstance(id, int):
                 menu_item = wx.MenuItem(self, *argv) # <- menu_item.Id
                 if icons:
                     menu_item.SetBitmaps(*icons)
                 self.Append(menu_item)
                 try:
-                    owner.Bind(wx.EVT_MENU, handlers[0], menu_item)
-                    owner.Bind(wx.EVT_UPDATE_UI, handlers[1], menu_item)
-                    owner.Bind(wx.EVT_MENU_HIGHLIGHT, handlers[2], menu_item)
+                    self.owner.Bind(wx.EVT_MENU, handlers[0], menu_item)
+                    self.owner.Bind(wx.EVT_UPDATE_UI, handlers[1], menu_item)
+                    self.owner.Bind(wx.EVT_MENU_HIGHLIGHT, handlers[2], menu_item)
                 except IndexError:
                     pass
             else:
                 subitems = list(argv.pop())
                 submenu = Menu(owner, subitems)
                 submenu_item = wx.MenuItem(self, wx.ID_ANY, *argv)
                 submenu_item.SetSubMenu(submenu)
                 if icons:
                     submenu_item.SetBitmaps(*icons)
                 self.Append(submenu_item)
                 self.Enable(submenu_item.Id, len(subitems)) # Disable an empty menu.
                 submenu.Id = submenu_item.Id # <- ID_ANY (dummy to check empty sbumenu)
     
+    def _unbind(self):
+        for item in self.MenuItems:
+            if item.Id != wx.ID_SEPARATOR:
+                self.owner.Unbind(wx.EVT_MENU, item)
+                self.owner.Unbind(wx.EVT_UPDATE_UI, item)
+                self.owner.Unbind(wx.EVT_MENU_HIGHLIGHT, item)
+            if item.SubMenu:
+                item.SubMenu._unbind()
+    
+    def Destroy(self):
+        try:
+            self._unbind()
+        finally:
+            return wx.Menu.Destroy(self)
+    
     @staticmethod
-    def Popup(parent, menu, *args, **kwargs):
-        menu = Menu(parent, menu)
+    def Popup(parent, menulist, *args, **kwargs):
+        menu = Menu(parent, menulist)
         parent.PopupMenu(menu, *args, **kwargs)
         menu.Destroy()
 
 
 class MenuBar(wx.MenuBar, TreeList):
     """MenuBar control
     
@@ -518,18 +534,16 @@
         """
         if self.Parent:
             menu = self.getmenu(key)
             if not menu:
                 self.reset()
                 return
             
+            menu._unbind()
             for item in menu.MenuItems: # delete all items
-                self.Parent.Unbind(wx.EVT_MENU, item)
-                self.Parent.Unbind(wx.EVT_UPDATE_UI, item)
-                self.Parent.Unbind(wx.EVT_MENU_HIGHLIGHT, item)
                 menu.Delete(item)
             
             menu2 = Menu(self.Parent, self[key]) # new menu2 to swap menu
             for item in menu2.MenuItems:
                 menu.Append(menu2.Remove(item)) # 重複しないようにいったん切り離して追加する
             
             if hasattr(menu, 'Id'):
@@ -538,18 +552,14 @@
     def reset(self):
         """Recreates menubar if the Parent were attached by SetMenuBar.
         Call when the menulist is changed.
         """
         if self.Parent:
             for j in range(self.GetMenuCount()): # remove and del all top-level menu
                 menu = self.Remove(0)
-                for item in menu.MenuItems: # delete all items
-                    self.Parent.Unbind(wx.EVT_MENU, item)
-                    self.Parent.Unbind(wx.EVT_UPDATE_UI, item)
-                    self.Parent.Unbind(wx.EVT_MENU_HIGHLIGHT, item)
                 menu.Destroy()
             
             for j, (key, values) in enumerate(self):
                 menu = Menu(self.Parent, values)
                 self.Append(menu, key)
                 if not values:
                     self.EnableTop(j, False) # Disable empty main menu.
@@ -1169,36 +1179,39 @@
         self.Init()
     
     SESSION_FILE = get_rootpath(".debrc")
     SCRATCH_FILE = get_rootpath("scratch.py")
     LOGGING_FILE = get_rootpath("deb-logging.log")
     HISTORY_FILE = get_rootpath("deb-history.log")
     
-    def load_session(self, rc=None, flush=True):
+    def load_session(self, f=None, flush=True):
         """Load session from file."""
-        if not rc:
+        if not f:
             with wx.FileDialog(self, 'Load session',
                     wildcard="Session file (*.debrc)|*.debrc",
                     style=wx.FD_OPEN|wx.FD_FILE_MUST_EXIST|wx.FD_CHANGE_DIR) as dlg:
                 if dlg.ShowModal() != wx.ID_OK:
                     return
-                rc = dlg.Path
+                f = dlg.Path
         
         if flush:
             for book in self.all_books:
                 book.delete_all_buffers()
         
-        self.SESSION_FILE = os.path.abspath(rc)
-        try:
-            scratch = self.Scratch.default_buffer
-            if not scratch or scratch.mtdelta is not None:
-                scratch = self.Scratch.new_buffer()
-            scratch.LoadFile(self.SCRATCH_FILE)
-        except FileNotFoundError as e:
-            print(e)
+        def _fload(editor, filename):
+            try:
+                buffer = editor.default_buffer or editor.new_buffer()
+                buffer.LoadFile(filename)
+                buffer.EmptyUndoBuffer()
+            except Exception:
+                pass
+        
+        _fload(self.Scratch, self.SCRATCH_FILE) # restore scratch
+        
+        self.SESSION_FILE = os.path.abspath(f)
         try:
             with open(self.SESSION_FILE, encoding='utf-8', newline='') as i:
                 exec(i.read())
         except Exception:
             ## pass
             traceback.print_exc()
     
@@ -1210,17 +1223,25 @@
                 style=wx.FD_SAVE|wx.FD_OVERWRITE_PROMPT) as dlg:
             if dlg.ShowModal() == wx.ID_OK:
                 self.SESSION_FILE = dlg.Path
                 self.save_session()
     
     def save_session(self):
         """Save session to file."""
-        scratch = self.Scratch.default_buffer
-        if scratch and scratch.mtdelta is None:
-            scratch.SaveFile(self.SCRATCH_FILE)
+        def _fsave(editor, filename):
+            try:
+                buffer = editor.default_buffer
+                buffer.SaveFile(filename)
+                buffer.SetSavePoint()
+            except Exception:
+                pass
+        
+        _fsave(self.Scratch, self.SCRATCH_FILE) # save scratch
+        _fsave(self.Log,     self.LOGGING_FILE)
+        _fsave(self.History, self.HISTORY_FILE)
         
         with open(self.SESSION_FILE, 'w', encoding='utf-8', newline='') as o:
             o.write("#! Session file (This file is generated automatically)\n")
             
             for book in self.all_books:
                 for buf in book.all_buffers:
                     if buf.mtdelta is not None:
@@ -1245,18 +1266,14 @@
         self.add_log(msg)
         self.load_session(self.SESSION_FILE)
     
     def Destroy(self):
         try:
             self.timer.Stop()
             self.save_session()
-            if self.Log.default_buffer:
-                self.Log.default_buffer.SaveFile(self.LOGGING_FILE)
-            if self.History.default_buffer:
-                self.History.default_buffer.SaveFile(self.HISTORY_FILE)
         finally:
             self._mgr.UnInit()
             return MiniFrame.Destroy(self)
     
     def OnClose(self, evt):
         if self.debugger.busy:
             if wx.MessageBox( # Confirm debugger close.
@@ -1771,61 +1788,66 @@
     from wx import core # PY3
 
     def _EvtHandler_Bind(self, event, handler=None, source=None, id=wx.ID_ANY, id2=wx.ID_ANY):
         """
         Bind an event to an event handler.
         (override) Record the handler in the list and return the handler.
         """
+        if handler is None:
+            return lambda f: _EvtHandler_Bind(self, event, f, source, id, id2)
+        
         assert isinstance(event, wx.PyEventBinder)
         assert callable(handler) or handler is None
         assert source is None or hasattr(source, 'GetId')
-        if handler is None:
-            return lambda f: _EvtHandler_Bind(self, event, f, source, id, id2)
         if source is not None:
             id  = source.GetId()
         event.Bind(self, id, id2, handler)
-        ## Record all handlers as a single state machine
+        
+        ## Record all handlers.
         try:
-            if not hasattr(self, '__event_handler__'):
-                self.__event_handler__ = {}
-            if event.typeId not in self.__event_handler__:
-                self.__event_handler__[event.typeId] = [handler]
-            else:
-                self.__event_handler__[event.typeId].insert(0, handler)
-        except Exception as e:
-            print("An error occurred in Bind: {}".format(e))
-            t, v, tb = sys.exc_info()
-            traceback.print_stack(tb.tb_frame.f_back)
-            traceback.print_exc()
+            vmap = self.__event_handler__
+        except AttributeError:
+            vmap = self.__event_handler__ = {}
+        try:
+            vmap[event.typeId].insert(0, (id, handler))
+        except KeyError:
+            vmap[event.typeId] = [(id, handler)]
         return handler
 
     core.EvtHandler.Bind = _EvtHandler_Bind
     ## del _EvtHandler_Bind
 
     def _EvtHandler_Unbind(self, event, source=None, id=wx.ID_ANY, id2=wx.ID_ANY, handler=None):
         """
         Disconnects the event handler binding for event from `self`.
         Returns ``True`` if successful.
         (override) Delete the handler from the list.
         """
         if source is not None:
             id  = source.GetId()
         retval = event.Unbind(self, id, id2, handler)
-        ## Remove the specified handler or all handlers
+        
+        ## Remove the specified handler or all handlers.
         if retval:
             try:
-                actions = self.__event_handler__[event.typeId]
-                if handler is None:
-                    actions.clear()
+                vmap = self.__event_handler__
+            except AttributeError:
+                return retval
+            try:
+                handlers = vmap[event.typeId]
+                if handler or id != wx.ID_ANY:
+                    for v in handlers.copy():
+                        if v[0] == id or v[1] == handler:
+                            handlers.remove(v)
                 else:
-                    actions.remove(handler)
-                if not actions:
-                    del self.__event_handler__[event.typeId]
-            except Exception:
-                pass
+                    handlers.pop(0) # No optional arguments are specified.
+                if not handlers:
+                    del vmap[event.typeId]
+            except KeyError:
+                pass # Note: vmap is actually inconsistent, but ignored.
         return retval
 
     core.EvtHandler.Unbind = _EvtHandler_Unbind
     ## del _EvtHandler_Unbind
 
     del core
```

## mwx/nutshell.py

```diff
@@ -1623,28 +1623,28 @@
     ## File I/O
     ## --------------------------------
     
     def _load_textfile(self, text, filename, lineno=0):
         with self.off_readonly():
             self.Text = text
             self.EmptyUndoBuffer()
-            self.SetSavePoint()
+            ## self.SetSavePoint()
         self.markline = lineno - 1
         self.goto_marker(1)
         self.filename = filename
         self.handler('buffer_loaded', self)
     
     def _load_file(self, filename, lineno=0):
         """Wrapped method of LoadFile."""
         if self.LoadFile(filename):
             self.markline = lineno - 1
             self.goto_marker(1)
             self.filename = filename
             self.EmptyUndoBuffer()
-            self.SetSavePoint()
+            ## self.SetSavePoint()
             self.handler('buffer_loaded', self)
             return True
         return False
     
     def _save_file(self, filename):
         """Wrapped method of SaveFile."""
         if self.SaveFile(filename):
@@ -2831,15 +2831,15 @@
             - pullback  : x@y --> y(x)
             - partial   : x@(y1,,,yn) --> partial(y1,,,yn)(x)
             - apropos   : x.y?p --> apropos(x,y,,,p)
         
         Note:
             This is called before run, execute, and original magic.
         """
-        sep1 = "`@=+-/*%<>&|^~;\t\r\n#"   # [`] ops, seps (no space, no comma)
+        sep1 = "`@=;\r\n#"                # [`] no ops, no spaces, no comma
         sep2 = "`@=+-/*%<>&|^~;, \t\r\n#" # [@] ops, seps
         
         def _popiter(ls, f):
             p = f if callable(f) else re.compile(f).match
             while ls and p(ls[0]):
                 yield ls.pop(0)
```

## mwx/wxmon.py

```diff
@@ -115,27 +115,14 @@
         return next(x for x in ew._eventBinders if x.typeId == event)
     
     @staticmethod
     def get_watchlist():
         """All watched event binders except noWatchList."""
         return (x for x in ew._eventBinders if x not in ew._noWatchList)
     
-    @staticmethod
-    def get_actions(event, widget):
-        """Wx.PyEventBinder and the handlers."""
-        try:
-            handlers = widget.__event_handler__[event]
-            ## Exclude ew:onWatchedEvent by comparing names instead of objects
-            ## cf. [a for a in handlers if a != self.onWatchedEvent]
-            return [a for a in handlers if a.__name__ != 'onWatchedEvent']
-        except AttributeError:
-            pass
-        except KeyError:
-            print("- No such event: {}".format(event))
-    
     def watch(self, widget=None):
         """Begin watching the widget."""
         self.clear()
         self.unwatch()
         if widget is None:
             widget = self.__prev # Restart
         if not widget:
@@ -176,28 +163,29 @@
         evt.Skip()
     
     def dump(self, widget, verbose=True):
         """Dump all event handlers bound to the widget."""
         exclusions = [x.typeId for x in ew._noWatchList]
         ssmap = {}
         try:
-            for event in sorted(widget.__event_handler__):
-                actions = self.get_actions(event, widget)
+            for event, handlers in sorted(widget.__event_handler__.items()):
+                actions = [v for k, v in handlers if v.__name__ != 'onWatchedEvent']
                 if actions and event not in exclusions:
                     ssmap[event] = actions
                     if verbose:
                         name = self.get_name(event)
-                        values = ('\n'+' '*41).join(str(where(a)) for a in actions)
-                        print("{:8d}:{:32s}{!s}".format(event, name, values))
+                        print("{:8d}:{}".format(event, name))
+                        for v in actions:
+                            print(' '*8, "> {}".format(where(v)))
         except AttributeError:
             pass
         return ssmap
     
     ## --------------------------------
-    ## Actions for event-logger items
+    ## Actions on list items
     ## --------------------------------
     
     def clear(self):
         self.DeleteAllItems()
         del self.__items[:]
     
     def update(self, evt):
```

## mwx/wxwil.py

```diff
@@ -81,14 +81,18 @@
                 self.blink(i)
         finally:
             self.Thaw()
     
     def unwatch(self):
         self.target = None
     
+    ## --------------------------------
+    ## Actions on list items
+    ## --------------------------------
+    
     def clear(self):
         self.DeleteAllItems()
         del self.__items[:]
     
     def update(self):
         if not self.target:
             return
```

## mwx/wxwit.py

```diff
@@ -138,14 +138,18 @@
         shell = self.parent.current_shell
         if shell is not obj:
             shell.locals[ref] = obj
             self.parent.message("self.{} -> {!r}".format(ref, obj))
         shell.SetFocus()
         return shell
     
+    ## --------------------------------
+    ## Actions on tree items
+    ## --------------------------------
+    
     def OnTimer(self, evt):
         ## wnd, pt = wx.FindWindowAtPointer() # as HitTest
         wnd = wx.Window.FindFocus()
         if (wnd and wnd is not self.target
                 and wnd not in self._noWatchList):
             self.SetObj(wnd)
         evt.Skip()
```

## Comparing `mwxlib-0.85.3.dist-info/LICENSE` & `mwxlib-0.85.6.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `mwxlib-0.85.3.dist-info/METADATA` & `mwxlib-0.85.6.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: mwxlib
-Version: 0.85.3
+Version: 0.85.6
 Summary: A wrapper of matplotlib and wxPython (phoenix)
 Home-page: https://github.com/komoto48g/mwxlib
 Author: Kazuya O'moto <komoto@jeol.co.jp>
 Author-email: komoto@jeol.co.jp
 License: MIT
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Programming Language :: Python :: 3
```

## Comparing `mwxlib-0.85.3.dist-info/RECORD` & `mwxlib-0.85.6.dist-info/RECORD`

 * *Files 25% similar despite different names*

```diff
@@ -1,22 +1,22 @@
 mwx/__init__.py,sha256=bSRdncjfSCKycMFQVnagOi9R2vUCC5snGkjea7jqPgU,2520
 mwx/controls.py,sha256=GjPK6XqLZANqXS0jY1YJyMo-UJrH60u-qkKA6ESw3QA,44266
-mwx/framework.py,sha256=skYQkfX-Z1aAWJ5omiGmjXGHgKFcL2I_ZUw2s5pC9CI,72480
+mwx/framework.py,sha256=fT6Sxnio_gpyDrfvOB8iRcMGiVoBWZc-N5pEtWdhHoc,72783
 mwx/graphman.py,sha256=vQAO19MyRFdAAQVyaGzEn-WJy5yrkQwtWNr7UKcHgT8,68631
 mwx/images.py,sha256=Xyvsq9m_R8JYERHA4Z3YznnUXbXkR7eUG7Cia1v1k2c,45726
 mwx/matplot2.py,sha256=W_FpY0S33crCAh7N9YTXo-jgYzj8uL9gqXkekfQo7Pk,36017
 mwx/matplot2g.py,sha256=cBuLMnQt3XSKQL9io0XJb_v8Lv0pO9hm0IMjVIERtu4,68253
 mwx/matplot2lg.py,sha256=vVlBulRQDyYonI9EKfqp-3SpNbGyIJQ6ldkw6bZlalo,27598
 mwx/mgplt.py,sha256=49_wpFZUEKErQmtobqrlNKDjWlAsdLft-izlqSyGPD0,6878
-mwx/nutshell.py,sha256=_GMnufsr6HLpAIBiWN7QAnn_hZKsAiHJIsoCPAE7o3U,139026
+mwx/nutshell.py,sha256=V_EbHJlXOE2JDFHMk3nhYAtTGo_kI9f3jWkzT_EnBbo,139029
 mwx/utilus.py,sha256=PDEJhTfDlFrcOe5w6zmU5EHmAfqIDOu74fKewi1rybY,37369
-mwx/wxmon.py,sha256=xfbpsFz18oX4Fyfx0MM2qrZid-fQuAsxxof41Yn23LI,11670
+mwx/wxmon.py,sha256=JQ4sv-QDvMyqIXDektJZvvWD5ED0T30duAXLLcnO4cg,11175
 mwx/wxpdb.py,sha256=BKr8HVJQx8uC-yPS6am3ifD_sl89Ar-xEBi5scf7vm8,19456
-mwx/wxwil.py,sha256=DPXXx4OdEzvHr-_jxz9J29Ozufmb6Vr7rXVkG_LKQd0,5254
-mwx/wxwit.py,sha256=MVpG18Ha6zi68cpQZleRC4qlpCZBmi4ogr9tOybqNXk,8196
+mwx/wxwil.py,sha256=_kyqGfKd6zRDKriHQehSkhQhv09dXizGqW3MkKA5MZ0,5372
+mwx/wxwit.py,sha256=G_86UM-99fPq7s8aiYoTXS1TiEWiFV9PbtgUfbrEmT4,8314
 mwx/py/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 mwx/py/filling.py,sha256=f6KMBcBv7gwrl6qmJYLTL-O0Z47bWNAdTCZtUZIo8vM,16794
-mwxlib-0.85.3.dist-info/LICENSE,sha256=PGtRKCaTkmUDlBQwpptJAxJtdqxIUtAmdBsaT9nUVkA,1091
-mwxlib-0.85.3.dist-info/METADATA,sha256=PSmyDugHmJtio1oItQ5bb16Y3yJazM5RrEi2c-_rmM0,1893
-mwxlib-0.85.3.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-mwxlib-0.85.3.dist-info/top_level.txt,sha256=SI1Mh118AstnUFGPNq5aMNKiAnVNmZk1S9Ij-OwAEpY,4
-mwxlib-0.85.3.dist-info/RECORD,,
+mwxlib-0.85.6.dist-info/LICENSE,sha256=PGtRKCaTkmUDlBQwpptJAxJtdqxIUtAmdBsaT9nUVkA,1091
+mwxlib-0.85.6.dist-info/METADATA,sha256=siDnSCvz7wHWF-uekVuAwzpF0jKzDAgrKGYPmOdZy-8,1893
+mwxlib-0.85.6.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+mwxlib-0.85.6.dist-info/top_level.txt,sha256=SI1Mh118AstnUFGPNq5aMNKiAnVNmZk1S9Ij-OwAEpY,4
+mwxlib-0.85.6.dist-info/RECORD,,
```

